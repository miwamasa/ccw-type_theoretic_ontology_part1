# Morpheus DSL 実装仕様書 Part 2

**Version**: 1.0.0-draft  
**Date**: 2025-01  
**Status**: Implementation Ready  
**Scope**: 第10章〜第16章（実装・運用部分）

---

## 目次

10. [コード生成](#10-コード生成)
11. [ランタイムライブラリ](#11-ランタイムライブラリ)
12. [CLI設計](#12-cli設計)
13. [エラー処理](#13-エラー処理)
14. [テスト戦略](#14-テスト戦略)
15. [実装ロードマップ](#15-実装ロードマップ)
16. [完全なサンプル実装](#16-完全なサンプル実装)

---

## 10. コード生成

### 10.1 コード生成の概要

MIR（Morpheus IR）から各ターゲット言語へのコード生成を行う。

```
MIR
 │
 ├─→ TypeScript Codegen ─→ .ts files
 │
 ├─→ Python Codegen ─→ .py files
 │
 ├─→ JSON Schema Gen ─→ .json files
 │
 └─→ Documentation Gen ─→ .md files
```

### 10.2 TypeScript コード生成

#### 10.2.1 生成されるファイル構成

```
output/
├── types.ts           # 型定義（スキーマ、列挙型）
├── units.ts           # 単位定義
├── lookups.ts         # ルックアップテーブル型
├── transforms/
│   ├── index.ts
│   └── [name].ts      # 各変換関数
├── pipelines/
│   ├── index.ts
│   └── [name].ts      # 各パイプライン
└── index.ts           # エントリーポイント
```

#### 10.2.2 TypeScript Codegen実装

```typescript
// src/codegen/typescript/ts-codegen.ts

import * as MIR from '../../ir/mir';

export class TypeScriptCodegen {
  private output: string[] = [];
  private indent = 0;

  generate(program: MIR.MIRProgram): Map<string, string> {
    const files = new Map<string, string>();
    
    // types.ts - スキーマと列挙型
    files.set('types.ts', this.generateTypes(program));
    
    // units.ts - 単位定義
    files.set('units.ts', this.generateUnits(program));
    
    // lookups.ts - ルックアップ
    files.set('lookups.ts', this.generateLookups(program));
    
    // transforms/*.ts - 変換関数
    for (const [name, transform] of program.transforms) {
      files.set(`transforms/${name}.ts`, this.generateTransform(transform, program));
    }
    
    // pipelines/*.ts - パイプライン
    for (const [name, pipeline] of program.pipelines) {
      files.set(`pipelines/${name}.ts`, this.generatePipeline(pipeline, program));
    }
    
    // index.ts - エントリーポイント
    files.set('index.ts', this.generateIndex(program));
    
    return files;
  }

  // ========== 型生成 ==========

  private generateTypes(program: MIR.MIRProgram): string {
    this.output = [];
    
    this.emit("// Auto-generated by Morpheus DSL Compiler");
    this.emit("// Do not edit manually");
    this.emit("");
    this.emit("import { Quantity } from '@morpheus/runtime';");
    this.emit("");
    
    // 列挙型
    for (const [name, enumDef] of program.enums) {
      this.generateEnum(enumDef);
      this.emit("");
    }
    
    // スキーマ型
    for (const [name, schema] of program.schemas) {
      this.generateSchema(schema);
      this.emit("");
    }
    
    return this.output.join('\n');
  }

  private generateEnum(enumDef: MIR.MIREnum): void {
    this.emit(`export enum ${enumDef.name} {`);
    this.indent++;
    for (const variant of enumDef.variants) {
      this.emit(`${variant} = '${variant}',`);
    }
    this.indent--;
    this.emit("}");
  }

  private generateSchema(schema: MIR.MIRSchema): string {
    this.emit(`export interface ${schema.name} {`);
    this.indent++;
    
    for (const field of schema.fields) {
      const tsType = this.mirTypeToTS(field.type);
      const optional = field.type.kind === 'Optional' ? '?' : '';
      this.emit(`${field.name}${optional}: ${tsType};`);
    }
    
    this.indent--;
    this.emit("}");
    return '';
  }

  private mirTypeToTS(type: MIR.MIRType): string {
    switch (type.kind) {
      case 'Primitive':
        return this.primitiveToTS(type.name);
      case 'Schema':
        return type.name;
      case 'Enum':
        return type.name;
      case 'Array':
        return `${this.mirTypeToTS(type.element)}[]`;
      case 'Optional':
        return `${this.mirTypeToTS(type.inner)} | null`;
      case 'Quantity':
        return `Quantity<'${type.unit}'>`;
      case 'Tuple':
        return `[${type.elements.map(e => this.mirTypeToTS(e)).join(', ')}]`;
      case 'Union':
        return type.members.map(m => this.mirTypeToTS(m)).join(' | ');
      default:
        return 'unknown';
    }
  }

  private primitiveToTS(name: string): string {
    switch (name) {
      case 'String': return 'string';
      case 'Int':
      case 'Float': return 'number';
      case 'Bool': return 'boolean';
      case 'Date':
      case 'DateTime': return 'Date';
      case 'Void': return 'void';
      default: return 'unknown';
    }
  }

  // ========== 単位生成 ==========

  private generateUnits(program: MIR.MIRProgram): string {
    this.output = [];
    
    this.emit("// Auto-generated unit definitions");
    this.emit("");
    this.emit("import { Unit, createUnit } from '@morpheus/runtime';");
    this.emit("");
    
    for (const [name, unit] of program.units) {
      const dims = Array.from(unit.dimensions.entries())
        .map(([d, e]) => `['${d}', ${e}]`)
        .join(', ');
      
      this.emit(`export const ${name}: Unit = createUnit(`);
      this.indent++;
      this.emit(`new Map([${dims}]),`);
      this.emit(`${unit.scale}`);
      this.indent--;
      this.emit(`);`);
      this.emit("");
    }
    
    return this.output.join('\n');
  }

  // ========== ルックアップ生成 ==========

  private generateLookups(program: MIR.MIRProgram): string {
    this.output = [];
    
    this.emit("// Auto-generated lookup definitions");
    this.emit("");
    this.emit("import { createLookup, Lookup } from '@morpheus/runtime';");
    this.emit("import * as Types from './types';");
    this.emit("");
    
    for (const [name, lookup] of program.lookups) {
      const keyType = this.mirTypeToTS(lookup.keyType);
      const valueType = this.mirTypeToTS(lookup.valueType);
      
      this.emit(`export const ${name}: Lookup<${keyType}, ${valueType}> = createLookup(`);
      this.indent++;
      this.emit(`'${lookup.source}',`);
      if (lookup.hasDefault) {
        this.emit(`{ hasDefault: true }`);
      }
      this.indent--;
      this.emit(`);`);
      this.emit("");
    }
    
    return this.output.join('\n');
  }

  // ========== 変換関数生成 ==========

  private generateTransform(transform: MIR.MIRTransform, program: MIR.MIRProgram): string {
    this.output = [];
    
    const sourceType = this.mirTypeToTS(transform.sourceType);
    const targetType = this.mirTypeToTS(transform.targetType);
    
    this.emit("// Auto-generated transform");
    this.emit("");
    this.emit("import { Quantity, multiply, add, sum, collect, filter } from '@morpheus/runtime';");
    this.emit("import * as Types from '../types';");
    this.emit("import * as Lookups from '../lookups';");
    this.emit("");
    
    // 変換関数の生成
    this.emit(`export function ${transform.name}(source: ${sourceType}): ${targetType} {`);
    this.indent++;
    
    // MIRブロックからコードを生成
    this.generateBlock(transform.body);
    
    this.indent--;
    this.emit("}");
    
    return this.output.join('\n');
  }

  private generateBlock(block: MIR.MIRBlock): void {
    // 一時変数を宣言
    const temps = this.collectTemps(block.instructions);
    for (const temp of temps) {
      this.emit(`let ${temp}: any;`);
    }
    
    if (temps.size > 0) {
      this.emit("");
    }
    
    // ターゲットオブジェクトを初期化
    this.emit("const result: any = {};");
    this.emit("");
    
    // 命令を生成
    for (const instr of block.instructions) {
      this.generateInstruction(instr);
    }
    
    this.emit("");
    this.emit("return result;");
  }

  private generateInstruction(instr: MIR.MIRInstruction): void {
    switch (instr.kind) {
      case 'Assign':
        this.emit(`${instr.target} = ${this.generateValue(instr.value)};`);
        break;
      
      case 'FieldGet':
        this.emit(`${instr.target} = ${this.generateValue(instr.object)}.${instr.field};`);
        break;
      
      case 'FieldSet':
        const path = instr.field.split('.');
        if (path.length === 1) {
          this.emit(`result.${instr.field} = ${this.generateValue(instr.value)};`);
        } else {
          // ネストしたパスの処理
          this.emit(`// Setting nested field: ${instr.field}`);
          this.generateNestedFieldSet(path, instr.value);
        }
        break;
      
      case 'BinOp':
        const op = this.translateBinOp(instr.op);
        const left = this.generateValue(instr.left);
        const right = this.generateValue(instr.right);
        
        if (this.isQuantityOp(instr.op)) {
          // Quantity演算はランタイム関数を使用
          this.emit(`${instr.target} = ${op}(${left}, ${right});`);
        } else {
          this.emit(`${instr.target} = ${left} ${op} ${right};`);
        }
        break;
      
      case 'Lookup':
        const key = this.generateValue(instr.key);
        if (instr.default) {
          const defaultVal = this.generateValue(instr.default);
          this.emit(`${instr.target} = Lookups.${instr.table}.get(${key}) ?? ${defaultVal};`);
        } else {
          this.emit(`${instr.target} = Lookups.${instr.table}.get(${key});`);
        }
        break;
      
      case 'Aggregate':
        this.generateAggregateInstr(instr);
        break;
      
      case 'Branch':
        this.emit(`if (${this.generateValue(instr.condition)}) {`);
        this.indent++;
        this.generateBlock(instr.thenBlock);
        this.indent--;
        this.emit(`} else {`);
        this.indent++;
        this.generateBlock(instr.elseBlock);
        this.indent--;
        this.emit(`}`);
        break;
      
      case 'Call':
        const args = instr.args.map(a => this.generateValue(a)).join(', ');
        this.emit(`${instr.target} = ${instr.func}(${args});`);
        break;
    }
  }

  private generateAggregateInstr(instr: MIR.MIRAggregateInstr): void {
    const source = this.generateValue(instr.source);
    const param = instr.lambdaParam;
    
    switch (instr.func) {
      case 'sum':
        this.emit(`${instr.target} = sum(${source}, (${param}) => {`);
        this.indent++;
        this.generateBlock(instr.lambdaBody);
        this.indent--;
        this.emit(`});`);
        break;
      
      case 'collect':
        this.emit(`${instr.target} = ${source}.map((${param}) => {`);
        this.indent++;
        this.generateBlock(instr.lambdaBody);
        this.indent--;
        this.emit(`});`);
        break;
      
      case 'filter':
        this.emit(`${instr.target} = ${source}.filter((${param}) => {`);
        this.indent++;
        this.generateBlock(instr.lambdaBody);
        this.indent--;
        this.emit(`});`);
        break;
      
      case 'avg':
        this.emit(`${instr.target} = avg(${source}, (${param}) => {`);
        this.indent++;
        this.generateBlock(instr.lambdaBody);
        this.indent--;
        this.emit(`});`);
        break;
      
      case 'max':
      case 'min':
        this.emit(`${instr.target} = ${instr.func}(${source}, (${param}) => {`);
        this.indent++;
        this.generateBlock(instr.lambdaBody);
        this.indent--;
        this.emit(`});`);
        break;
      
      case 'count':
        this.emit(`${instr.target} = ${source}.length;`);
        break;
    }
  }

  private generateValue(value: MIR.MIRValue): string {
    switch (value.kind) {
      case 'Var':
        return value.name;
      case 'IntLit':
      case 'FloatLit':
        return String(value.value);
      case 'StringLit':
        return JSON.stringify(value.value);
      case 'BoolLit':
        return String(value.value);
      case 'Null':
        return 'null';
      case 'SourceRef':
        return 'source';
      case 'TargetRef':
        return `result.${value.field}`;
      default:
        return 'undefined';
    }
  }

  private generateNestedFieldSet(path: string[], value: MIR.MIRValue): void {
    // ネストしたオブジェクトを自動生成
    let current = 'result';
    for (let i = 0; i < path.length - 1; i++) {
      this.emit(`${current}.${path[i]} = ${current}.${path[i]} ?? {};`);
      current = `${current}.${path[i]}`;
    }
    this.emit(`${current}.${path[path.length - 1]} = ${this.generateValue(value)};`);
  }

  private translateBinOp(op: string): string {
    switch (op) {
      case '+': return 'add';
      case '-': return 'subtract';
      case '*': return 'multiply';
      case '/': return 'divide';
      default: return op;
    }
  }

  private isQuantityOp(op: string): boolean {
    return ['+', '-', '*', '/'].includes(op);
  }

  private collectTemps(instructions: MIR.MIRInstruction[]): Set<string> {
    const temps = new Set<string>();
    for (const instr of instructions) {
      if ('target' in instr && typeof instr.target === 'string') {
        if (instr.target.startsWith('_t')) {
          temps.add(instr.target);
        }
      }
    }
    return temps;
  }

  // ========== パイプライン生成 ==========

  private generatePipeline(pipeline: MIR.MIRPipeline, program: MIR.MIRProgram): string {
    this.output = [];
    
    this.emit("// Auto-generated pipeline");
    this.emit("");
    
    // 使用する変換をインポート
    const transforms = pipeline.steps
      .filter(s => s.kind === 'Transform')
      .map(s => (s as { kind: 'Transform'; name: string }).name);
    
    for (const name of transforms) {
      this.emit(`import { ${name} } from '../transforms/${name}';`);
    }
    this.emit("");
    
    // パイプライン関数
    this.emit(`export function ${pipeline.name}(input: any): any {`);
    this.indent++;
    this.emit("let data = input;");
    this.emit("");
    
    for (const step of pipeline.steps) {
      switch (step.kind) {
        case 'Transform':
          this.emit(`data = ${step.name}(data);`);
          break;
        case 'Parallel':
          this.emit(`// Parallel execution`);
          this.emit(`const results = await Promise.all([`);
          this.indent++;
          for (const t of step.transforms) {
            this.emit(`${t}(data),`);
          }
          this.indent--;
          this.emit(`]);`);
          this.emit(`data = Object.assign({}, ...results);`);
          break;
        case 'Conditional':
          this.emit(`if (${this.generateValue(step.condition as any)}) {`);
          this.indent++;
          this.emit(`data = ${step.transform}(data);`);
          this.indent--;
          this.emit(`}`);
          break;
      }
    }
    
    this.emit("");
    this.emit("return data;");
    this.indent--;
    this.emit("}");
    
    return this.output.join('\n');
  }

  // ========== インデックス生成 ==========

  private generateIndex(program: MIR.MIRProgram): string {
    this.output = [];
    
    this.emit("// Auto-generated index");
    this.emit("// Morpheus DSL Compiler");
    this.emit("");
    
    this.emit("// Types");
    this.emit("export * from './types';");
    this.emit("");
    
    this.emit("// Units");
    this.emit("export * from './units';");
    this.emit("");
    
    this.emit("// Lookups");
    this.emit("export * from './lookups';");
    this.emit("");
    
    this.emit("// Transforms");
    for (const name of program.transforms.keys()) {
      this.emit(`export { ${name} } from './transforms/${name}';`);
    }
    this.emit("");
    
    this.emit("// Pipelines");
    for (const name of program.pipelines.keys()) {
      this.emit(`export { ${name} } from './pipelines/${name}';`);
    }
    
    return this.output.join('\n');
  }

  // ========== ユーティリティ ==========

  private emit(line: string): void {
    const indentStr = '  '.repeat(this.indent);
    this.output.push(indentStr + line);
  }
}
```

### 10.3 Python コード生成

#### 10.3.1 生成されるファイル構成

```
output/
├── types.py           # 型定義（dataclass）
├── units.py           # 単位定義
├── lookups.py         # ルックアップ
├── transforms/
│   ├── __init__.py
│   └── [name].py
├── pipelines/
│   ├── __init__.py
│   └── [name].py
└── __init__.py
```

#### 10.3.2 Python Codegen実装

```typescript
// src/codegen/python/py-codegen.ts

import * as MIR from '../../ir/mir';

export class PythonCodegen {
  private output: string[] = [];
  private indent = 0;

  generate(program: MIR.MIRProgram): Map<string, string> {
    const files = new Map<string, string>();
    
    files.set('types.py', this.generateTypes(program));
    files.set('units.py', this.generateUnits(program));
    files.set('lookups.py', this.generateLookups(program));
    
    for (const [name, transform] of program.transforms) {
      files.set(`transforms/${name}.py`, this.generateTransform(transform, program));
    }
    
    files.set('transforms/__init__.py', this.generateTransformsInit(program));
    files.set('__init__.py', this.generateMainInit(program));
    
    return files;
  }

  private generateTypes(program: MIR.MIRProgram): string {
    this.output = [];
    
    this.emit("# Auto-generated by Morpheus DSL Compiler");
    this.emit("from dataclasses import dataclass");
    this.emit("from typing import Optional, List, Union");
    this.emit("from decimal import Decimal");
    this.emit("from datetime import date, datetime");
    this.emit("from morpheus_runtime import Quantity");
    this.emit("");
    
    // 列挙型
    for (const [name, enumDef] of program.enums) {
      this.emit("from enum import Enum");
      this.emit("");
      this.emit(`class ${enumDef.name}(Enum):`);
      this.indent++;
      for (const variant of enumDef.variants) {
        this.emit(`${variant} = '${variant}'`);
      }
      this.indent--;
      this.emit("");
    }
    
    // スキーマ型（dataclass）
    for (const [name, schema] of program.schemas) {
      this.emit("@dataclass");
      this.emit(`class ${schema.name}:`);
      this.indent++;
      
      if (schema.fields.length === 0) {
        this.emit("pass");
      } else {
        for (const field of schema.fields) {
          const pyType = this.mirTypeToPython(field.type);
          if (field.type.kind === 'Optional') {
            this.emit(`${field.name}: ${pyType} = None`);
          } else {
            this.emit(`${field.name}: ${pyType}`);
          }
        }
      }
      
      this.indent--;
      this.emit("");
    }
    
    return this.output.join('\n');
  }

  private mirTypeToPython(type: MIR.MIRType): string {
    switch (type.kind) {
      case 'Primitive':
        return this.primitiveToPython(type.name);
      case 'Schema':
        return `'${type.name}'`;  // Forward reference
      case 'Enum':
        return type.name;
      case 'Array':
        return `List[${this.mirTypeToPython(type.element)}]`;
      case 'Optional':
        return `Optional[${this.mirTypeToPython(type.inner)}]`;
      case 'Quantity':
        return `Quantity['${type.unit}']`;
      case 'Tuple':
        const elements = type.elements.map(e => this.mirTypeToPython(e)).join(', ');
        return `tuple[${elements}]`;
      case 'Union':
        const members = type.members.map(m => this.mirTypeToPython(m)).join(', ');
        return `Union[${members}]`;
      default:
        return 'Any';
    }
  }

  private primitiveToPython(name: string): string {
    switch (name) {
      case 'String': return 'str';
      case 'Int': return 'int';
      case 'Float': return 'float';
      case 'Bool': return 'bool';
      case 'Date': return 'date';
      case 'DateTime': return 'datetime';
      case 'Void': return 'None';
      default: return 'Any';
    }
  }

  private generateTransform(transform: MIR.MIRTransform, program: MIR.MIRProgram): string {
    this.output = [];
    
    const sourceType = this.mirTypeToPython(transform.sourceType);
    const targetType = this.mirTypeToPython(transform.targetType);
    
    this.emit("# Auto-generated transform");
    this.emit("from typing import Any");
    this.emit("from morpheus_runtime import Quantity, multiply, add, sum_quantity");
    this.emit("from ..types import *");
    this.emit("from ..lookups import *");
    this.emit("");
    
    this.emit(`def ${transform.name}(source: ${sourceType}) -> ${targetType}:`);
    this.indent++;
    this.emit('"""');
    this.emit(`Transform ${sourceType} to ${targetType}`);
    this.emit('"""');
    
    // MIRブロックからPythonコードを生成
    this.generatePythonBlock(transform.body, targetType);
    
    this.indent--;
    
    return this.output.join('\n');
  }

  private generatePythonBlock(block: MIR.MIRBlock, targetType: string): void {
    this.emit("result = {}");
    this.emit("");
    
    for (const instr of block.instructions) {
      this.generatePythonInstruction(instr);
    }
    
    this.emit("");
    this.emit(`return ${targetType}(**result)`);
  }

  private generatePythonInstruction(instr: MIR.MIRInstruction): void {
    switch (instr.kind) {
      case 'Assign':
        this.emit(`${instr.target} = ${this.generatePythonValue(instr.value)}`);
        break;
      
      case 'FieldGet':
        this.emit(`${instr.target} = ${this.generatePythonValue(instr.object)}.${instr.field}`);
        break;
      
      case 'FieldSet':
        this.emit(`result['${instr.field}'] = ${this.generatePythonValue(instr.value)}`);
        break;
      
      case 'BinOp':
        const left = this.generatePythonValue(instr.left);
        const right = this.generatePythonValue(instr.right);
        
        if (this.isQuantityOp(instr.op)) {
          const func = this.translatePythonBinOp(instr.op);
          this.emit(`${instr.target} = ${func}(${left}, ${right})`);
        } else {
          this.emit(`${instr.target} = ${left} ${instr.op} ${right}`);
        }
        break;
      
      case 'Lookup':
        const key = this.generatePythonValue(instr.key);
        this.emit(`${instr.target} = ${instr.table}.get(${key})`);
        break;
      
      case 'Aggregate':
        this.generatePythonAggregate(instr);
        break;
    }
  }

  private generatePythonAggregate(instr: MIR.MIRAggregateInstr): void {
    const source = this.generatePythonValue(instr.source);
    const param = instr.lambdaParam;
    
    switch (instr.func) {
      case 'sum':
        this.emit(`${instr.target} = sum_quantity(`);
        this.indent++;
        this.emit(`${source},`);
        this.emit(`lambda ${param}: ${this.generateLambdaBody(instr.lambdaBody)}`);
        this.indent--;
        this.emit(`)`)
        break;
      
      case 'collect':
        this.emit(`${instr.target} = [`);
        this.indent++;
        this.emit(`${this.generateLambdaBody(instr.lambdaBody)}`);
        this.emit(`for ${param} in ${source}`);
        this.indent--;
        this.emit(`]`);
        break;
      
      case 'filter':
        this.emit(`${instr.target} = [`);
        this.indent++;
        this.emit(`${param} for ${param} in ${source}`);
        this.emit(`if ${this.generateLambdaBody(instr.lambdaBody)}`);
        this.indent--;
        this.emit(`]`);
        break;
    }
  }

  private generateLambdaBody(block: MIR.MIRBlock): string {
    // 簡略化: 単一の式を返す場合のみ
    if (block.instructions.length === 0) {
      return this.generatePythonValue(block.result);
    }
    // 複雑なケースは別途処理
    return this.generatePythonValue(block.result);
  }

  private generatePythonValue(value: MIR.MIRValue): string {
    switch (value.kind) {
      case 'Var':
        return value.name;
      case 'IntLit':
        return String(value.value);
      case 'FloatLit':
        return String(value.value);
      case 'StringLit':
        return `'${value.value.replace(/'/g, "\\'")}'`;
      case 'BoolLit':
        return value.value ? 'True' : 'False';
      case 'Null':
        return 'None';
      case 'SourceRef':
        return 'source';
      case 'TargetRef':
        return `result['${value.field}']`;
      default:
        return 'None';
    }
  }

  private translatePythonBinOp(op: string): string {
    switch (op) {
      case '+': return 'add';
      case '-': return 'subtract';
      case '*': return 'multiply';
      case '/': return 'divide';
      default: return op;
    }
  }

  private isQuantityOp(op: string): boolean {
    return ['+', '-', '*', '/'].includes(op);
  }

  private generateTransformsInit(program: MIR.MIRProgram): string {
    this.output = [];
    
    for (const name of program.transforms.keys()) {
      this.emit(`from .${name} import ${name}`);
    }
    this.emit("");
    this.emit("__all__ = [");
    this.indent++;
    for (const name of program.transforms.keys()) {
      this.emit(`'${name}',`);
    }
    this.indent--;
    this.emit("]");
    
    return this.output.join('\n');
  }

  private generateMainInit(program: MIR.MIRProgram): string {
    this.output = [];
    
    this.emit("# Morpheus Generated Code");
    this.emit("from .types import *");
    this.emit("from .units import *");
    this.emit("from .lookups import *");
    this.emit("from .transforms import *");
    
    return this.output.join('\n');
  }

  // ========== ユーティリティ ==========
  
  private emit(line: string): void {
    const indentStr = '    '.repeat(this.indent);
    this.output.push(indentStr + line);
  }
}
```

### 10.4 JSON Schema生成

```typescript
// src/codegen/json-schema/schema-gen.ts

import * as MIR from '../../ir/mir';

export class JSONSchemaGenerator {
  generate(program: MIR.MIRProgram): Map<string, object> {
    const schemas = new Map<string, object>();
    
    for (const [name, schema] of program.schemas) {
      schemas.set(`${name}.schema.json`, this.generateSchemaJSON(schema, program));
    }
    
    return schemas;
  }

  private generateSchemaJSON(schema: MIR.MIRSchema, program: MIR.MIRProgram): object {
    const properties: Record<string, object> = {};
    const required: string[] = [];
    
    for (const field of schema.fields) {
      properties[field.name] = this.typeToJSONSchema(field.type, program);
      
      if (field.type.kind !== 'Optional') {
        required.push(field.name);
      }
    }
    
    return {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": schema.name,
      "type": "object",
      "properties": properties,
      "required": required,
      "additionalProperties": false
    };
  }

  private typeToJSONSchema(type: MIR.MIRType, program: MIR.MIRProgram): object {
    switch (type.kind) {
      case 'Primitive':
        return this.primitiveToJSONSchema(type.name);
      
      case 'Schema':
        return { "$ref": `${type.name}.schema.json` };
      
      case 'Enum':
        const enumDef = program.enums.get(type.name);
        return {
          "type": "string",
          "enum": enumDef?.variants ?? []
        };
      
      case 'Array':
        return {
          "type": "array",
          "items": this.typeToJSONSchema(type.element, program)
        };
      
      case 'Optional':
        return {
          "oneOf": [
            this.typeToJSONSchema(type.inner, program),
            { "type": "null" }
          ]
        };
      
      case 'Quantity':
        return {
          "type": "object",
          "properties": {
            "value": { "type": "number" },
            "unit": { "type": "string", "const": type.unit }
          },
          "required": ["value", "unit"]
        };
      
      case 'Tuple':
        return {
          "type": "array",
          "items": type.elements.map(e => this.typeToJSONSchema(e, program)),
          "minItems": type.elements.length,
          "maxItems": type.elements.length
        };
      
      case 'Union':
        return {
          "oneOf": type.members.map(m => this.typeToJSONSchema(m, program))
        };
      
      default:
        return {};
    }
  }

  private primitiveToJSONSchema(name: string): object {
    switch (name) {
      case 'String':
        return { "type": "string" };
      case 'Int':
        return { "type": "integer" };
      case 'Float':
        return { "type": "number" };
      case 'Bool':
        return { "type": "boolean" };
      case 'Date':
        return { "type": "string", "format": "date" };
      case 'DateTime':
        return { "type": "string", "format": "date-time" };
      default:
        return {};
    }
  }
}
```

---

## 11. ランタイムライブラリ

### 11.1 TypeScriptランタイム

#### 11.1.1 パッケージ構成

```
@morpheus/runtime/
├── src/
│   ├── quantity.ts       # Quantity型と演算
│   ├── unit.ts           # Unit型
│   ├── lookup.ts         # Lookupテーブル
│   ├── aggregates.ts     # 集約関数
│   ├── validation.ts     # バリデーション
│   └── index.ts
├── package.json
└── tsconfig.json
```

#### 11.1.2 Quantity実装

```typescript
// @morpheus/runtime/src/quantity.ts

export interface Unit {
  dimensions: Map<string, number>;
  scale: number;
}

export interface Quantity<U extends string = string> {
  value: number;
  unit: U;
  _unitDef?: Unit;
}

export function createQuantity<U extends string>(
  value: number,
  unit: U,
  unitDef?: Unit
): Quantity<U> {
  return { value, unit, _unitDef: unitDef };
}

export function add<U extends string>(
  a: Quantity<U>,
  b: Quantity<U>
): Quantity<U> {
  if (a.unit !== b.unit) {
    throw new Error(`Unit mismatch: cannot add ${a.unit} and ${b.unit}`);
  }
  return createQuantity(a.value + b.value, a.unit, a._unitDef);
}

export function subtract<U extends string>(
  a: Quantity<U>,
  b: Quantity<U>
): Quantity<U> {
  if (a.unit !== b.unit) {
    throw new Error(`Unit mismatch: cannot subtract ${a.unit} and ${b.unit}`);
  }
  return createQuantity(a.value - b.value, a.unit, a._unitDef);
}

export function multiply<U1 extends string, U2 extends string>(
  a: Quantity<U1>,
  b: Quantity<U2>
): Quantity<`${U1}*${U2}`> {
  const resultUnit = `${a.unit}*${b.unit}` as `${U1}*${U2}`;
  const resultUnitDef = multiplyUnits(a._unitDef, b._unitDef);
  return createQuantity(a.value * b.value, resultUnit, resultUnitDef);
}

export function divide<U1 extends string, U2 extends string>(
  a: Quantity<U1>,
  b: Quantity<U2>
): Quantity<`${U1}/${U2}`> {
  if (b.value === 0) {
    throw new Error('Division by zero');
  }
  const resultUnit = `${a.unit}/${b.unit}` as `${U1}/${U2}`;
  const resultUnitDef = divideUnits(a._unitDef, b._unitDef);
  return createQuantity(a.value / b.value, resultUnit, resultUnitDef);
}

export function multiplyScalar<U extends string>(
  q: Quantity<U>,
  scalar: number
): Quantity<U> {
  return createQuantity(q.value * scalar, q.unit, q._unitDef);
}

function multiplyUnits(a?: Unit, b?: Unit): Unit | undefined {
  if (!a || !b) return undefined;
  
  const dimensions = new Map(a.dimensions);
  for (const [dim, exp] of b.dimensions) {
    dimensions.set(dim, (dimensions.get(dim) ?? 0) + exp);
  }
  
  // 0になった次元を削除
  for (const [dim, exp] of dimensions) {
    if (exp === 0) dimensions.delete(dim);
  }
  
  return { dimensions, scale: a.scale * b.scale };
}

function divideUnits(a?: Unit, b?: Unit): Unit | undefined {
  if (!a || !b) return undefined;
  
  const dimensions = new Map(a.dimensions);
  for (const [dim, exp] of b.dimensions) {
    dimensions.set(dim, (dimensions.get(dim) ?? 0) - exp);
  }
  
  for (const [dim, exp] of dimensions) {
    if (exp === 0) dimensions.delete(dim);
  }
  
  return { dimensions, scale: a.scale / b.scale };
}

// 単位の正規化と簡約
export function simplifyUnit(unitStr: string): string {
  // 簡略化: 単位文字列の正規化ロジック
  // 例: "kg*m/s^2" -> "N" (ニュートン)
  return unitStr;
}
```

#### 11.1.3 Lookup実装

```typescript
// @morpheus/runtime/src/lookup.ts

export interface LookupOptions {
  hasDefault?: boolean;
  loadAsync?: boolean;
}

export interface Lookup<K, V> {
  get(key: K): V;
  getAsync(key: K): Promise<V>;
  has(key: K): boolean;
}

export function createLookup<K, V>(
  source: string,
  options: LookupOptions = {}
): Lookup<K, V> {
  // 実際の実装ではファイルまたはAPIからデータをロード
  const data = new Map<K, V>();
  let defaultValue: V | undefined;
  
  return {
    get(key: K): V {
      const value = data.get(key);
      if (value === undefined) {
        if (options.hasDefault && defaultValue !== undefined) {
          return defaultValue;
        }
        throw new Error(`Lookup key not found: ${key}`);
      }
      return value;
    },
    
    async getAsync(key: K): Promise<V> {
      // 非同期版（APIコール等）
      return this.get(key);
    },
    
    has(key: K): boolean {
      return data.has(key);
    }
  };
}

// ファイルからルックアップをロード
export async function loadLookupFromCSV<K extends string, V>(
  path: string,
  keyColumn: string,
  valueColumn: string
): Promise<Map<K, V>> {
  // CSV読み込みロジック
  const map = new Map<K, V>();
  // ...
  return map;
}

// JSONからルックアップをロード
export async function loadLookupFromJSON<K extends string, V>(
  path: string
): Promise<Map<K, V>> {
  // JSON読み込みロジック
  const map = new Map<K, V>();
  // ...
  return map;
}
```

#### 11.1.4 集約関数実装

```typescript
// @morpheus/runtime/src/aggregates.ts

import { Quantity, add, createQuantity } from './quantity';

export function sum<T, U extends string>(
  items: T[],
  selector: (item: T) => Quantity<U>
): Quantity<U> {
  if (items.length === 0) {
    throw new Error('Cannot sum empty array');
  }
  
  let result = selector(items[0]);
  for (let i = 1; i < items.length; i++) {
    result = add(result, selector(items[i]));
  }
  
  return result;
}

export function sumNumbers<T>(
  items: T[],
  selector: (item: T) => number
): number {
  return items.reduce((acc, item) => acc + selector(item), 0);
}

export function avg<T, U extends string>(
  items: T[],
  selector: (item: T) => Quantity<U>
): Quantity<U> {
  const total = sum(items, selector);
  return createQuantity(total.value / items.length, total.unit, total._unitDef);
}

export function max<T>(
  items: T[],
  selector: (item: T) => number
): number {
  if (items.length === 0) {
    throw new Error('Cannot find max of empty array');
  }
  return Math.max(...items.map(selector));
}

export function min<T>(
  items: T[],
  selector: (item: T) => number
): number {
  if (items.length === 0) {
    throw new Error('Cannot find min of empty array');
  }
  return Math.min(...items.map(selector));
}

export function count<T>(items: T[]): number {
  return items.length;
}

export function collect<T, R>(
  items: T[],
  selector: (item: T) => R
): R[] {
  return items.map(selector);
}

export function filter<T>(
  items: T[],
  predicate: (item: T) => boolean
): T[] {
  return items.filter(predicate);
}

export function groupBy<T, K extends string, R>(
  items: T[],
  keySelector: (item: T) => K,
  resultSelector: (key: K, group: T[]) => R
): R[] {
  const groups = new Map<K, T[]>();
  
  for (const item of items) {
    const key = keySelector(item);
    if (!groups.has(key)) {
      groups.set(key, []);
    }
    groups.get(key)!.push(item);
  }
  
  const results: R[] = [];
  for (const [key, group] of groups) {
    results.push(resultSelector(key, group));
  }
  
  return results;
}
```

### 11.2 Pythonランタイム

#### 11.2.1 パッケージ構成

```
morpheus_runtime/
├── __init__.py
├── quantity.py
├── unit.py
├── lookup.py
├── aggregates.py
└── validation.py
```

#### 11.2.2 Quantity実装

```python
# morpheus_runtime/quantity.py

from dataclasses import dataclass
from typing import TypeVar, Generic, Dict, Optional
from decimal import Decimal

U = TypeVar('U', bound=str)

@dataclass
class Unit:
    dimensions: Dict[str, int]
    scale: float = 1.0
    
    def __mul__(self, other: 'Unit') -> 'Unit':
        dims = dict(self.dimensions)
        for dim, exp in other.dimensions.items():
            dims[dim] = dims.get(dim, 0) + exp
        # Remove zero exponents
        dims = {k: v for k, v in dims.items() if v != 0}
        return Unit(dims, self.scale * other.scale)
    
    def __truediv__(self, other: 'Unit') -> 'Unit':
        dims = dict(self.dimensions)
        for dim, exp in other.dimensions.items():
            dims[dim] = dims.get(dim, 0) - exp
        dims = {k: v for k, v in dims.items() if v != 0}
        return Unit(dims, self.scale / other.scale)


@dataclass
class Quantity(Generic[U]):
    value: float
    unit: str
    unit_def: Optional[Unit] = None
    
    def __add__(self, other: 'Quantity[U]') -> 'Quantity[U]':
        if self.unit != other.unit:
            raise ValueError(f"Unit mismatch: cannot add {self.unit} and {other.unit}")
        return Quantity(self.value + other.value, self.unit, self.unit_def)
    
    def __sub__(self, other: 'Quantity[U]') -> 'Quantity[U]':
        if self.unit != other.unit:
            raise ValueError(f"Unit mismatch: cannot subtract {self.unit} and {other.unit}")
        return Quantity(self.value - other.value, self.unit, self.unit_def)
    
    def __mul__(self, other: 'Quantity') -> 'Quantity':
        result_unit = f"{self.unit}*{other.unit}"
        result_unit_def = None
        if self.unit_def and other.unit_def:
            result_unit_def = self.unit_def * other.unit_def
        return Quantity(self.value * other.value, result_unit, result_unit_def)
    
    def __truediv__(self, other: 'Quantity') -> 'Quantity':
        if other.value == 0:
            raise ZeroDivisionError("Division by zero")
        result_unit = f"{self.unit}/{other.unit}"
        result_unit_def = None
        if self.unit_def and other.unit_def:
            result_unit_def = self.unit_def / other.unit_def
        return Quantity(self.value / other.value, result_unit, result_unit_def)
    
    def __repr__(self) -> str:
        return f"{self.value} {self.unit}"


def multiply(a: Quantity, b: Quantity) -> Quantity:
    return a * b

def divide(a: Quantity, b: Quantity) -> Quantity:
    return a / b

def add(a: Quantity, b: Quantity) -> Quantity:
    return a + b

def subtract(a: Quantity, b: Quantity) -> Quantity:
    return a - b
```

#### 11.2.3 集約関数実装

```python
# morpheus_runtime/aggregates.py

from typing import TypeVar, Callable, List, Dict, Tuple, Any
from .quantity import Quantity

T = TypeVar('T')
R = TypeVar('R')
K = TypeVar('K')

def sum_quantity(
    items: List[T],
    selector: Callable[[T], Quantity]
) -> Quantity:
    """Sum quantities from items using a selector function."""
    if not items:
        raise ValueError("Cannot sum empty list")
    
    result = selector(items[0])
    for item in items[1:]:
        result = result + selector(item)
    return result

def sum_numbers(
    items: List[T],
    selector: Callable[[T], float]
) -> float:
    """Sum numbers from items using a selector function."""
    return sum(selector(item) for item in items)

def avg_quantity(
    items: List[T],
    selector: Callable[[T], Quantity]
) -> Quantity:
    """Calculate average of quantities."""
    total = sum_quantity(items, selector)
    return Quantity(total.value / len(items), total.unit, total.unit_def)

def max_value(
    items: List[T],
    selector: Callable[[T], float]
) -> float:
    """Find maximum value."""
    if not items:
        raise ValueError("Cannot find max of empty list")
    return max(selector(item) for item in items)

def min_value(
    items: List[T],
    selector: Callable[[T], float]
) -> float:
    """Find minimum value."""
    if not items:
        raise ValueError("Cannot find min of empty list")
    return min(selector(item) for item in items)

def collect(
    items: List[T],
    selector: Callable[[T], R]
) -> List[R]:
    """Map items to a new list."""
    return [selector(item) for item in items]

def filter_items(
    items: List[T],
    predicate: Callable[[T], bool]
) -> List[T]:
    """Filter items by predicate."""
    return [item for item in items if predicate(item)]

def group_by(
    items: List[T],
    key_selector: Callable[[T], K],
    result_selector: Callable[[K, List[T]], R]
) -> List[R]:
    """Group items and transform each group."""
    groups: Dict[K, List[T]] = {}
    
    for item in items:
        key = key_selector(item)
        if key not in groups:
            groups[key] = []
        groups[key].append(item)
    
    return [result_selector(key, group) for key, group in groups.items()]
```

---

## 12. CLI設計

### 12.1 コマンド概要

```
morpheus <command> [options] [files...]

Commands:
  check     Type-check Morpheus source files
  compile   Compile to target language
  run       Execute transform on data
  docs      Generate documentation
  init      Initialize new project
  test      Run tests
  format    Format source files
  lsp       Start Language Server Protocol server

Global Options:
  --version, -v    Show version
  --help, -h       Show help
  --verbose        Enable verbose output
  --config, -c     Config file path (default: morpheus.config.json)
```

### 12.2 CLI実装

```typescript
// src/cli/index.ts

import { Command } from 'commander';
import { checkCommand } from './commands/check';
import { compileCommand } from './commands/compile';
import { runCommand } from './commands/run';
import { docsCommand } from './commands/docs';
import { initCommand } from './commands/init';
import { testCommand } from './commands/test';
import { formatCommand } from './commands/format';
import { lspCommand } from './commands/lsp';
import { version } from '../../package.json';

const program = new Command();

program
  .name('morpheus')
  .description('Morpheus DSL - Type-safe ontology transformations')
  .version(version);

// check コマンド
program
  .command('check')
  .description('Type-check Morpheus source files')
  .argument('[files...]', 'Source files to check')
  .option('--strict', 'Enable strict mode')
  .option('--watch, -w', 'Watch mode')
  .action(checkCommand);

// compile コマンド
program
  .command('compile')
  .description('Compile Morpheus to target language')
  .argument('[files...]', 'Source files to compile')
  .option('--target, -t <lang>', 'Target language (typescript|python|json)', 'typescript')
  .option('--outdir, -o <dir>', 'Output directory', './dist')
  .option('--emit-types', 'Emit type definitions only')
  .option('--sourcemap', 'Generate source maps')
  .option('--watch, -w', 'Watch mode')
  .action(compileCommand);

// run コマンド
program
  .command('run')
  .description('Execute a transform on input data')
  .argument('<transform>', 'Transform or pipeline name')
  .option('--input, -i <file>', 'Input data file (JSON)')
  .option('--output, -o <file>', 'Output file')
  .option('--lookups <dir>', 'Lookup data directory')
  .option('--format <fmt>', 'Output format (json|csv|yaml)', 'json')
  .action(runCommand);

// docs コマンド
program
  .command('docs')
  .description('Generate documentation')
  .argument('[files...]', 'Source files')
  .option('--outdir, -o <dir>', 'Output directory', './docs')
  .option('--format <fmt>', 'Output format (markdown|html)', 'markdown')
  .action(docsCommand);

// init コマンド
program
  .command('init')
  .description('Initialize a new Morpheus project')
  .argument('[name]', 'Project name')
  .option('--template <name>', 'Project template')
  .action(initCommand);

// test コマンド
program
  .command('test')
  .description('Run transform tests')
  .argument('[files...]', 'Test files')
  .option('--watch, -w', 'Watch mode')
  .option('--coverage', 'Generate coverage report')
  .action(testCommand);

// format コマンド
program
  .command('format')
  .description('Format Morpheus source files')
  .argument('[files...]', 'Files to format')
  .option('--check', 'Check formatting without changes')
  .option('--write', 'Write formatted files')
  .action(formatCommand);

// lsp コマンド
program
  .command('lsp')
  .description('Start Language Server Protocol server')
  .option('--stdio', 'Use stdio for communication')
  .option('--port <port>', 'TCP port for communication')
  .action(lspCommand);

program.parse();
```

### 12.3 各コマンドの実装

#### 12.3.1 check コマンド

```typescript
// src/cli/commands/check.ts

import * as fs from 'fs';
import * as path from 'path';
import { Lexer } from '../../lexer';
import { Parser } from '../../parser';
import { TypeChecker } from '../../analyzer/type-checker';
import { ErrorReporter } from '../../errors';

interface CheckOptions {
  strict?: boolean;
  watch?: boolean;
}

export async function checkCommand(files: string[], options: CheckOptions): Promise<void> {
  const reporter = new ErrorReporter();
  
  if (files.length === 0) {
    files = findMorpheusFiles('.');
  }
  
  let hasErrors = false;
  
  for (const file of files) {
    console.log(`Checking ${file}...`);
    
    try {
      const source = fs.readFileSync(file, 'utf-8');
      
      // Lexer
      const lexer = new Lexer(source, file);
      const tokens = lexer.tokenize();
      
      const lexErrors = tokens.filter(t => t.type === 'ERROR');
      if (lexErrors.length > 0) {
        for (const err of lexErrors) {
          reporter.reportError({
            message: err.literal as string,
            span: err.span,
            severity: 'error'
          });
        }
        hasErrors = true;
        continue;
      }
      
      // Parser
      const parser = new Parser(tokens);
      const { program, errors: parseErrors } = parser.parse();
      
      if (parseErrors.length > 0) {
        for (const err of parseErrors) {
          reporter.reportError({
            message: err.message,
            span: err.span,
            severity: 'error'
          });
        }
        hasErrors = true;
        continue;
      }
      
      // Type Checker
      const typeChecker = new TypeChecker();
      const { errors: typeErrors } = typeChecker.check(program);
      
      if (typeErrors.length > 0) {
        for (const err of typeErrors) {
          reporter.reportError({
            message: err.message,
            span: err.span,
            severity: 'error'
          });
        }
        hasErrors = true;
      }
      
    } catch (e) {
      reporter.reportError({
        message: `Failed to read file: ${e}`,
        severity: 'error'
      });
      hasErrors = true;
    }
  }
  
  reporter.printSummary();
  
  if (hasErrors) {
    process.exit(1);
  }
  
  console.log('✓ All files passed type checking');
}

function findMorpheusFiles(dir: string): string[] {
  const files: string[] = [];
  
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory() && entry.name !== 'node_modules') {
      files.push(...findMorpheusFiles(fullPath));
    } else if (entry.isFile() && entry.name.endsWith('.morpheus')) {
      files.push(fullPath);
    }
  }
  
  return files;
}
```

#### 12.3.2 compile コマンド

```typescript
// src/cli/commands/compile.ts

import * as fs from 'fs';
import * as path from 'path';
import { Lexer } from '../../lexer';
import { Parser } from '../../parser';
import { TypeChecker } from '../../analyzer/type-checker';
import { IRGenerator } from '../../ir/ir-gen';
import { Optimizer } from '../../ir/optimizer';
import { TypeScriptCodegen } from '../../codegen/typescript/ts-codegen';
import { PythonCodegen } from '../../codegen/python/py-codegen';
import { JSONSchemaGenerator } from '../../codegen/json-schema/schema-gen';

interface CompileOptions {
  target: 'typescript' | 'python' | 'json';
  outdir: string;
  emitTypes?: boolean;
  sourcemap?: boolean;
  watch?: boolean;
}

export async function compileCommand(files: string[], options: CompileOptions): Promise<void> {
  console.log(`Compiling to ${options.target}...`);
  
  // Parse all files
  const programs = [];
  for (const file of files) {
    const source = fs.readFileSync(file, 'utf-8');
    const lexer = new Lexer(source, file);
    const tokens = lexer.tokenize();
    const parser = new Parser(tokens);
    const { program, errors } = parser.parse();
    
    if (errors.length > 0) {
      console.error(`Parse errors in ${file}:`);
      errors.forEach(e => console.error(`  ${e.message}`));
      process.exit(1);
    }
    
    programs.push(program);
  }
  
  // Merge programs (if multiple files)
  const mergedProgram = mergePrograms(programs);
  
  // Type check
  const typeChecker = new TypeChecker();
  const { typedAST, errors: typeErrors } = typeChecker.check(mergedProgram);
  
  if (typeErrors.length > 0) {
    console.error('Type errors:');
    typeErrors.forEach(e => console.error(`  ${e.message}`));
    process.exit(1);
  }
  
  // Generate IR
  const irGen = new IRGenerator();
  const mir = irGen.generate(typedAST);
  
  // Optimize
  const optimizer = new Optimizer();
  const optimizedMIR = optimizer.optimize(mir);
  
  // Code generation
  let outputFiles: Map<string, string>;
  
  switch (options.target) {
    case 'typescript':
      const tsCodegen = new TypeScriptCodegen();
      outputFiles = tsCodegen.generate(optimizedMIR);
      break;
    
    case 'python':
      const pyCodegen = new PythonCodegen();
      outputFiles = pyCodegen.generate(optimizedMIR);
      break;
    
    case 'json':
      const jsonGen = new JSONSchemaGenerator();
      const schemas = jsonGen.generate(optimizedMIR);
      outputFiles = new Map();
      for (const [name, schema] of schemas) {
        outputFiles.set(name, JSON.stringify(schema, null, 2));
      }
      break;
    
    default:
      console.error(`Unknown target: ${options.target}`);
      process.exit(1);
  }
  
  // Write output files
  fs.mkdirSync(options.outdir, { recursive: true });
  
  for (const [filename, content] of outputFiles) {
    const outPath = path.join(options.outdir, filename);
    const dir = path.dirname(outPath);
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(outPath, content);
    console.log(`  Written: ${outPath}`);
  }
  
  console.log(`✓ Compiled ${outputFiles.size} files`);
}

function mergePrograms(programs: any[]): any {
  // 複数プログラムをマージする実装
  // 簡略化: 最初のプログラムを返す
  return programs[0];
}
```

### 12.4 設定ファイル

```json
// morpheus.config.json
{
  "compilerOptions": {
    "target": "typescript",
    "outDir": "./dist",
    "strict": true,
    "sourceMaps": true
  },
  "include": [
    "src/**/*.morpheus"
  ],
  "exclude": [
    "node_modules"
  ],
  "lookups": {
    "directory": "./data/lookups",
    "format": "csv"
  },
  "runtime": {
    "package": "@morpheus/runtime"
  }
}
```

---

## 13. エラー処理

### 13.1 エラー種別

```typescript
// src/errors/error-types.ts

import { SourceSpan } from '../lexer/token';

export type ErrorSeverity = 'error' | 'warning' | 'info' | 'hint';

export interface DiagnosticError {
  code: string;
  message: string;
  span?: SourceSpan;
  severity: ErrorSeverity;
  relatedInfo?: RelatedInfo[];
  suggestions?: Suggestion[];
}

export interface RelatedInfo {
  message: string;
  span: SourceSpan;
}

export interface Suggestion {
  message: string;
  replacement?: string;
}

// エラーコード定義
export const ErrorCodes = {
  // Lexer errors (L001-L099)
  L001: 'Unexpected character',
  L002: 'Unterminated string',
  L003: 'Unterminated block comment',
  L004: 'Invalid number format',
  
  // Parser errors (P001-P099)
  P001: 'Expected declaration',
  P002: 'Expected identifier',
  P003: 'Expected type expression',
  P004: 'Expected expression',
  P005: 'Unexpected token',
  P006: 'Missing closing brace',
  P007: 'Missing closing parenthesis',
  P008: 'Invalid mapping rule',
  
  // Type errors (T001-T199)
  T001: 'Unknown type',
  T002: 'Type mismatch',
  T003: 'Unknown field',
  T004: 'Missing required field',
  T005: 'Duplicate field',
  T006: 'Cannot apply operator',
  T007: 'Invalid array index',
  T008: 'Cannot call non-function',
  T009: 'Wrong number of arguments',
  T010: 'Unknown lookup table',
  T011: 'Unknown transform',
  T012: 'Circular reference',
  
  // Unit errors (U001-U099)
  U001: 'Unknown unit',
  U002: 'Unit mismatch in addition',
  U003: 'Invalid unit expression',
  U004: 'Incompatible dimensions',
  
  // Semantic errors (S001-S099)
  S001: 'Undefined variable',
  S002: 'Variable already defined',
  S003: 'Invalid target reference',
  S004: 'Self-referencing mapping',
  
  // Runtime errors (R001-R099)
  R001: 'Division by zero',
  R002: 'Null pointer',
  R003: 'Index out of bounds',
  R004: 'Lookup key not found',
} as const;
```

### 13.2 エラー報告

```typescript
// src/errors/error-reporter.ts

import chalk from 'chalk';
import { DiagnosticError, ErrorSeverity } from './error-types';
import { SourceSpan } from '../lexer/token';

export class ErrorReporter {
  private errors: DiagnosticError[] = [];
  private sources: Map<string, string> = new Map();

  addSource(file: string, content: string): void {
    this.sources.set(file, content);
  }

  reportError(error: DiagnosticError): void {
    this.errors.push(error);
  }

  hasErrors(): boolean {
    return this.errors.some(e => e.severity === 'error');
  }

  getErrors(): DiagnosticError[] {
    return this.errors;
  }

  printErrors(): void {
    for (const error of this.errors) {
      this.printError(error);
    }
  }

  printSummary(): void {
    const errorCount = this.errors.filter(e => e.severity === 'error').length;
    const warningCount = this.errors.filter(e => e.severity === 'warning').length;
    
    if (errorCount > 0 || warningCount > 0) {
      console.log();
      if (errorCount > 0) {
        console.log(chalk.red(`✗ ${errorCount} error(s)`));
      }
      if (warningCount > 0) {
        console.log(chalk.yellow(`⚠ ${warningCount} warning(s)`));
      }
    }
  }

  private printError(error: DiagnosticError): void {
    const colorFn = this.getColorFn(error.severity);
    const icon = this.getIcon(error.severity);
    
    // ヘッダー
    console.log();
    console.log(colorFn(`${icon} ${error.code}: ${error.message}`));
    
    // ソース位置
    if (error.span) {
      const location = this.formatLocation(error.span);
      console.log(chalk.gray(`  at ${location}`));
      
      // コードスニペット
      const snippet = this.getCodeSnippet(error.span);
      if (snippet) {
        console.log();
        console.log(snippet);
      }
    }
    
    // 関連情報
    if (error.relatedInfo) {
      for (const info of error.relatedInfo) {
        console.log(chalk.gray(`  → ${info.message}`));
        console.log(chalk.gray(`    at ${this.formatLocation(info.span)}`));
      }
    }
    
    // 提案
    if (error.suggestions) {
      console.log();
      for (const suggestion of error.suggestions) {
        console.log(chalk.blue(`  💡 ${suggestion.message}`));
        if (suggestion.replacement) {
          console.log(chalk.green(`     ${suggestion.replacement}`));
        }
      }
    }
  }

  private getCodeSnippet(span: SourceSpan): string | null {
    const source = this.sources.get(span.file);
    if (!source) return null;
    
    const lines = source.split('\n');
    const lineNum = span.start.line;
    const line = lines[lineNum - 1];
    
    if (!line) return null;
    
    const lineNumStr = String(lineNum).padStart(4, ' ');
    const padding = ' '.repeat(4 + 3);  // line number + " | "
    
    let result = '';
    result += chalk.gray(`${lineNumStr} | `) + line + '\n';
    result += chalk.gray(padding);
    result += ' '.repeat(span.start.column - 1);
    result += chalk.red('^'.repeat(Math.max(1, span.end.column - span.start.column)));
    
    return result;
  }

  private formatLocation(span: SourceSpan): string {
    return `${span.file}:${span.start.line}:${span.start.column}`;
  }

  private getColorFn(severity: ErrorSeverity): (s: string) => string {
    switch (severity) {
      case 'error': return chalk.red;
      case 'warning': return chalk.yellow;
      case 'info': return chalk.blue;
      case 'hint': return chalk.gray;
    }
  }

  private getIcon(severity: ErrorSeverity): string {
    switch (severity) {
      case 'error': return '✗';
      case 'warning': return '⚠';
      case 'info': return 'ℹ';
      case 'hint': return '💡';
    }
  }
}
```

### 13.3 エラーメッセージのテンプレート

```typescript
// src/errors/messages.ts

import { SourceSpan } from '../lexer/token';
import { DiagnosticError, ErrorCodes } from './error-types';

export function typeMismatch(
  expected: string,
  actual: string,
  span: SourceSpan
): DiagnosticError {
  return {
    code: 'T002',
    message: `Type mismatch: expected '${expected}', but got '${actual}'`,
    span,
    severity: 'error',
    suggestions: [
      {
        message: `Consider converting '${actual}' to '${expected}'`
      }
    ]
  };
}

export function unknownField(
  fieldName: string,
  schemaName: string,
  span: SourceSpan,
  suggestions?: string[]
): DiagnosticError {
  const error: DiagnosticError = {
    code: 'T003',
    message: `Unknown field '${fieldName}' in schema '${schemaName}'`,
    span,
    severity: 'error'
  };
  
  if (suggestions && suggestions.length > 0) {
    error.suggestions = suggestions.map(s => ({
      message: `Did you mean '${s}'?`
    }));
  }
  
  return error;
}

export function unitMismatch(
  unit1: string,
  unit2: string,
  operation: string,
  span: SourceSpan
): DiagnosticError {
  return {
    code: 'U002',
    message: `Cannot ${operation} values with different units: '${unit1}' and '${unit2}'`,
    span,
    severity: 'error',
    suggestions: [
      {
        message: 'Ensure both operands have the same unit'
      }
    ]
  };
}

export function missingRequiredField(
  fieldName: string,
  schemaName: string,
  span: SourceSpan
): DiagnosticError {
  return {
    code: 'T004',
    message: `Missing required field '${fieldName}' in mapping to '${schemaName}'`,
    span,
    severity: 'error',
    suggestions: [
      {
        message: `Add a mapping rule for '${fieldName}'`,
        replacement: `${fieldName} <- $.???`
      }
    ]
  };
}

export function circularReference(
  path: string[],
  span: SourceSpan
): DiagnosticError {
  return {
    code: 'T012',
    message: `Circular reference detected: ${path.join(' → ')}`,
    span,
    severity: 'error'
  };
}
```

---

## 14. テスト戦略

### 14.1 テスト構成

```
tests/
├── unit/
│   ├── lexer/
│   │   ├── lexer.test.ts
│   │   └── tokens.test.ts
│   ├── parser/
│   │   ├── parser.test.ts
│   │   ├── expressions.test.ts
│   │   └── declarations.test.ts
│   ├── analyzer/
│   │   ├── type-checker.test.ts
│   │   ├── unit-checker.test.ts
│   │   └── resolver.test.ts
│   └── codegen/
│       ├── typescript.test.ts
│       └── python.test.ts
│
├── integration/
│   ├── compile.test.ts
│   ├── runtime.test.ts
│   └── cli.test.ts
│
├── e2e/
│   ├── cfp-calculation/
│   ├── data-transform/
│   └── pipeline/
│
└── fixtures/
    ├── valid/
    ├── invalid/
    └── data/
```

### 14.2 ユニットテスト例

#### 14.2.1 Lexerテスト

```typescript
// tests/unit/lexer/lexer.test.ts

import { describe, it, expect } from 'vitest';
import { Lexer } from '../../../src/lexer';
import { TokenType } from '../../../src/lexer/token';

describe('Lexer', () => {
  describe('basic tokens', () => {
    it('should tokenize identifiers', () => {
      const lexer = new Lexer('foo bar_baz');
      const tokens = lexer.tokenize();
      
      expect(tokens[0].type).toBe(TokenType.IDENTIFIER);
      expect(tokens[0].lexeme).toBe('foo');
      expect(tokens[1].type).toBe(TokenType.IDENTIFIER);
      expect(tokens[1].lexeme).toBe('bar_baz');
    });

    it('should tokenize numbers', () => {
      const lexer = new Lexer('42 3.14 1e10');
      const tokens = lexer.tokenize();
      
      expect(tokens[0].type).toBe(TokenType.INT_LITERAL);
      expect(tokens[0].literal).toBe(42);
      expect(tokens[1].type).toBe(TokenType.FLOAT_LITERAL);
      expect(tokens[1].literal).toBeCloseTo(3.14);
      expect(tokens[2].type).toBe(TokenType.FLOAT_LITERAL);
      expect(tokens[2].literal).toBe(1e10);
    });

    it('should tokenize strings', () => {
      const lexer = new Lexer('"hello" "world\\n"');
      const tokens = lexer.tokenize();
      
      expect(tokens[0].type).toBe(TokenType.STRING_LITERAL);
      expect(tokens[0].literal).toBe('hello');
      expect(tokens[1].literal).toBe('world\n');
    });

    it('should tokenize keywords', () => {
      const lexer = new Lexer('schema transform if then else');
      const tokens = lexer.tokenize();
      
      expect(tokens[0].type).toBe(TokenType.SCHEMA);
      expect(tokens[1].type).toBe(TokenType.TRANSFORM);
      expect(tokens[2].type).toBe(TokenType.IF);
      expect(tokens[3].type).toBe(TokenType.THEN);
      expect(tokens[4].type).toBe(TokenType.ELSE);
    });
  });

  describe('operators', () => {
    it('should tokenize arrow operators', () => {
      const lexer = new Lexer('<- -> =>');
      const tokens = lexer.tokenize();
      
      expect(tokens[0].type).toBe(TokenType.LARROW);
      expect(tokens[1].type).toBe(TokenType.RARROW);
      expect(tokens[2].type).toBe(TokenType.FAT_ARROW);
    });

    it('should tokenize comparison operators', () => {
      const lexer = new Lexer('== != < > <= >=');
      const tokens = lexer.tokenize();
      
      expect(tokens[0].type).toBe(TokenType.EQ);
      expect(tokens[1].type).toBe(TokenType.NEQ);
      expect(tokens[2].type).toBe(TokenType.LT);
      expect(tokens[3].type).toBe(TokenType.GT);
      expect(tokens[4].type).toBe(TokenType.LTE);
      expect(tokens[5].type).toBe(TokenType.GTE);
    });
  });

  describe('comments', () => {
    it('should skip line comments', () => {
      const lexer = new Lexer('foo // comment\nbar');
      const tokens = lexer.tokenize();
      
      expect(tokens.filter(t => t.type === TokenType.IDENTIFIER)).toHaveLength(2);
    });

    it('should skip block comments', () => {
      const lexer = new Lexer('foo /* comment */ bar');
      const tokens = lexer.tokenize();
      
      expect(tokens.filter(t => t.type === TokenType.IDENTIFIER)).toHaveLength(2);
    });
  });

  describe('error handling', () => {
    it('should report unterminated string', () => {
      const lexer = new Lexer('"unterminated');
      const tokens = lexer.tokenize();
      
      expect(tokens.some(t => t.type === TokenType.ERROR)).toBe(true);
    });
  });
});
```

#### 14.2.2 Parserテスト

```typescript
// tests/unit/parser/parser.test.ts

import { describe, it, expect } from 'vitest';
import { Lexer } from '../../../src/lexer';
import { Parser } from '../../../src/parser';

describe('Parser', () => {
  function parse(source: string) {
    const lexer = new Lexer(source);
    const tokens = lexer.tokenize();
    const parser = new Parser(tokens);
    return parser.parse();
  }

  describe('schema declarations', () => {
    it('should parse simple schema', () => {
      const { program, errors } = parse(`
        schema Person {
          name: String
          age: Int
        }
      `);
      
      expect(errors).toHaveLength(0);
      expect(program.declarations).toHaveLength(1);
      
      const schema = program.declarations[0];
      expect(schema.kind).toBe('SchemaDecl');
      expect(schema.name).toBe('Person');
      expect(schema.fields).toHaveLength(2);
    });

    it('should parse schema with optional fields', () => {
      const { program, errors } = parse(`
        schema Person {
          name: String
          email: String?
        }
      `);
      
      expect(errors).toHaveLength(0);
      const schema = program.declarations[0];
      expect(schema.fields[1].type.kind).toBe('OptionalType');
    });

    it('should parse schema with array fields', () => {
      const { program, errors } = parse(`
        schema Order {
          items: [Item]
        }
      `);
      
      expect(errors).toHaveLength(0);
      const schema = program.declarations[0];
      expect(schema.fields[0].type.kind).toBe('ArrayType');
    });

    it('should parse schema with quantity fields', () => {
      const { program, errors } = parse(`
        schema Measurement {
          value: Quantity<kg>
        }
      `);
      
      expect(errors).toHaveLength(0);
      const schema = program.declarations[0];
      expect(schema.fields[0].type.kind).toBe('QuantityType');
    });
  });

  describe('transform declarations', () => {
    it('should parse simple transform', () => {
      const { program, errors } = parse(`
        transform Copy: Source -> Target {
          id <- $.id
          name <- $.name
        }
      `);
      
      expect(errors).toHaveLength(0);
      
      const transform = program.declarations[0];
      expect(transform.kind).toBe('TransformDecl');
      expect(transform.name).toBe('Copy');
      expect(transform.rules).toHaveLength(2);
    });

    it('should parse transform with expressions', () => {
      const { program, errors } = parse(`
        transform Calc: A -> B {
          total <- $.x + $.y * 2
        }
      `);
      
      expect(errors).toHaveLength(0);
      
      const transform = program.declarations[0];
      const rule = transform.rules[0];
      expect(rule.sourceExpr.kind).toBe('BinaryExpr');
    });

    it('should parse transform with lookup', () => {
      const { program, errors } = parse(`
        transform WithLookup: A -> B {
          factor <- lookup(Factors, $.key)
        }
      `);
      
      expect(errors).toHaveLength(0);
      
      const transform = program.declarations[0];
      const rule = transform.rules[0];
      expect(rule.sourceExpr.kind).toBe('LookupExpr');
    });

    it('should parse transform with aggregation', () => {
      const { program, errors } = parse(`
        transform Aggregate: A -> B {
          total <- sum($.items, |i| i.value)
        }
      `);
      
      expect(errors).toHaveLength(0);
      
      const transform = program.declarations[0];
      const rule = transform.rules[0];
      expect(rule.sourceExpr.kind).toBe('AggregateExpr');
      expect(rule.sourceExpr.func).toBe('sum');
    });
  });

  describe('expressions', () => {
    it('should parse path expressions', () => {
      const { program } = parse(`
        transform T: A -> B {
          x <- $.nested.field[0].value
        }
      `);
      
      const rule = program.declarations[0].rules[0];
      expect(rule.sourceExpr.kind).toBe('PathExpr');
    });

    it('should parse conditional expressions', () => {
      const { program } = parse(`
        transform T: A -> B {
          x <- if $.flag then $.a else $.b
        }
      `);
      
      const rule = program.declarations[0].rules[0];
      expect(rule.sourceExpr.kind).toBe('IfExpr');
    });

    it('should parse match expressions', () => {
      const { program } = parse(`
        transform T: A -> B {
          x <- match $.type {
            "A" => 1
            "B" => 2
            _ => 0
          }
        }
      `);
      
      const rule = program.declarations[0].rules[0];
      expect(rule.sourceExpr.kind).toBe('MatchExpr');
    });
  });
});
```

#### 14.2.3 型チェッカーテスト

```typescript
// tests/unit/analyzer/type-checker.test.ts

import { describe, it, expect } from 'vitest';
import { Lexer } from '../../../src/lexer';
import { Parser } from '../../../src/parser';
import { TypeChecker } from '../../../src/analyzer/type-checker';

describe('TypeChecker', () => {
  function check(source: string) {
    const lexer = new Lexer(source);
    const tokens = lexer.tokenize();
    const parser = new Parser(tokens);
    const { program } = parser.parse();
    const typeChecker = new TypeChecker();
    return typeChecker.check(program);
  }

  describe('schema type checking', () => {
    it('should accept valid schema', () => {
      const { errors } = check(`
        schema Person {
          name: String
          age: Int
        }
      `);
      
      expect(errors).toHaveLength(0);
    });

    it('should detect unknown type reference', () => {
      const { errors } = check(`
        schema Person {
          address: UnknownType
        }
      `);
      
      expect(errors.length).toBeGreaterThan(0);
      expect(errors[0].code).toBe('T001');
    });
  });

  describe('transform type checking', () => {
    it('should accept valid transform', () => {
      const { errors } = check(`
        schema Source { x: Int }
        schema Target { y: Int }
        
        transform T: Source -> Target {
          y <- $.x
        }
      `);
      
      expect(errors).toHaveLength(0);
    });

    it('should detect type mismatch', () => {
      const { errors } = check(`
        schema Source { x: String }
        schema Target { y: Int }
        
        transform T: Source -> Target {
          y <- $.x
        }
      `);
      
      expect(errors.length).toBeGreaterThan(0);
      expect(errors[0].code).toBe('T002');
    });

    it('should detect unknown field', () => {
      const { errors } = check(`
        schema Source { x: Int }
        schema Target { y: Int }
        
        transform T: Source -> Target {
          y <- $.unknownField
        }
      `);
      
      expect(errors.length).toBeGreaterThan(0);
      expect(errors[0].code).toBe('T003');
    });

    it('should detect missing required field', () => {
      const { errors } = check(`
        schema Source { x: Int }
        schema Target { y: Int, z: Int }
        
        transform T: Source -> Target {
          y <- $.x
        }
      `);
      
      expect(errors.length).toBeGreaterThan(0);
      expect(errors[0].code).toBe('T004');
    });
  });

  describe('unit type checking', () => {
    it('should accept valid unit operations', () => {
      const { errors } = check(`
        unit kg
        unit m
        
        schema Source { 
          mass: Quantity<kg>
          distance: Quantity<m>
        }
        schema Target { 
          total_mass: Quantity<kg>
        }
        
        transform T: Source -> Target {
          total_mass <- $.mass + $.mass
        }
      `);
      
      expect(errors).toHaveLength(0);
    });

    it('should detect unit mismatch in addition', () => {
      const { errors } = check(`
        unit kg
        unit m
        
        schema Source { 
          mass: Quantity<kg>
          distance: Quantity<m>
        }
        schema Target { 
          result: Quantity<kg>
        }
        
        transform T: Source -> Target {
          result <- $.mass + $.distance
        }
      `);
      
      expect(errors.length).toBeGreaterThan(0);
      expect(errors[0].code).toBe('U002');
    });

    it('should allow unit multiplication', () => {
      const { errors } = check(`
        unit kg
        unit m
        unit s
        
        schema Source { 
          mass: Quantity<kg>
          acceleration: Quantity<m/s^2>
        }
        schema Target { 
          force: Quantity<kg*m/s^2>
        }
        
        transform T: Source -> Target {
          force <- $.mass * $.acceleration
        }
      `);
      
      expect(errors).toHaveLength(0);
    });
  });
});
```

### 14.3 統合テスト

```typescript
// tests/integration/compile.test.ts

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';

describe('Compilation Integration', () => {
  const testDir = path.join(__dirname, '../fixtures/integration');
  const outDir = path.join(__dirname, '../output');

  beforeAll(() => {
    fs.mkdirSync(outDir, { recursive: true });
  });

  afterAll(() => {
    fs.rmSync(outDir, { recursive: true, force: true });
  });

  it('should compile CFP example to TypeScript', () => {
    const inputFile = path.join(testDir, 'cfp.morpheus');
    
    execSync(`morpheus compile ${inputFile} --target typescript --outdir ${outDir}`);
    
    expect(fs.existsSync(path.join(outDir, 'types.ts'))).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'transforms/ProductionToCFP.ts'))).toBe(true);
  });

  it('should generate runnable TypeScript', async () => {
    const inputFile = path.join(testDir, 'simple.morpheus');
    
    execSync(`morpheus compile ${inputFile} --target typescript --outdir ${outDir}`);
    
    // 生成されたコードをインポートして実行
    const { SimpleTransform } = await import(path.join(outDir, 'transforms/SimpleTransform'));
    
    const input = { x: 10 };
    const output = SimpleTransform(input);
    
    expect(output.y).toBe(20);
  });
});
```

### 14.4 E2Eテスト

```typescript
// tests/e2e/cfp-calculation/cfp.test.ts

import { describe, it, expect } from 'vitest';
import { ProductionToCFP } from '../../../examples/cfp-calculation/dist';
import { Quantity } from '@morpheus/runtime';

describe('CFP Calculation E2E', () => {
  it('should calculate CFP for a production record', () => {
    const input = {
      productId: 'PROD-001',
      process: {
        machineId: 'MC-001',
        electricityUsage: { value: 100, unit: 'kWh' },
        fuelUsage: { value: 5, unit: 'kg' },
        fuelType: 'diesel'
      },
      materials: [
        { code: 'steel', weight: { value: 10, unit: 'kg' } },
        { code: 'aluminum', weight: { value: 2, unit: 'kg' } }
      ],
      logistics: {
        inboundDistance: { value: 100, unit: 'km' },
        outboundDistance: { value: 50, unit: 'km' },
        transportMode: 'Truck',
        cargoWeight: { value: 12, unit: 'kg' }
      },
      waste: {
        amount: { value: 0.5, unit: 'kg' },
        disposalMethod: 'Incineration'
      }
    };

    const result = ProductionToCFP(input);

    expect(result.productId).toBe('PROD-001');
    expect(result.scope1.unit).toBe('kgCO2');
    expect(result.scope2.unit).toBe('kgCO2');
    expect(result.scope3Upstream.unit).toBe('kgCO2');
    expect(result.scope3Downstream.unit).toBe('kgCO2');
    expect(result.total.value).toBeGreaterThan(0);
    
    // 合計の検証
    const expectedTotal = 
      result.scope1.value + 
      result.scope2.value + 
      result.scope3Upstream.value + 
      result.scope3Downstream.value;
    
    expect(result.total.value).toBeCloseTo(expectedTotal);
  });
});
```

---

## 15. 実装ロードマップ

### 15.1 フェーズ概要

```
Phase 1: Foundation (4週間)
├── Week 1-2: Lexer & Parser
├── Week 3: Type System Core
└── Week 4: Basic TypeScript Codegen

Phase 2: Core Features (4週間)
├── Week 5: Unit System
├── Week 6: Type Checker Complete
├── Week 7: IR & Optimization
└── Week 8: Full TypeScript Codegen

Phase 3: Extended Features (4週間)
├── Week 9: Aggregations & Lookups
├── Week 10: Python Codegen
├── Week 11: CLI & Config
└── Week 12: Documentation & Examples

Phase 4: Polish (2週間)
├── Week 13: Error Messages & UX
└── Week 14: Testing & Release
```

### 15.2 Phase 1: Foundation

#### Week 1-2: Lexer & Parser

**タスク:**
- [ ] Token型定義
- [ ] Lexer実装
  - [ ] 基本トークン（識別子、リテラル）
  - [ ] キーワード認識
  - [ ] 演算子
  - [ ] コメント処理
- [ ] AST型定義
- [ ] Parser実装
  - [ ] 宣言のパース
  - [ ] 型式のパース
  - [ ] 式のパース（演算子優先順位）
  - [ ] エラー回復

**成果物:**
- `src/lexer/` - Lexer実装
- `src/parser/` - Parser実装
- `tests/unit/lexer/` - Lexerテスト
- `tests/unit/parser/` - Parserテスト

#### Week 3: Type System Core

**タスク:**
- [ ] 型定義（Type, Unit）
- [ ] シンボルテーブル
- [ ] 名前解決
- [ ] 基本的な型チェック
  - [ ] プリミティブ型
  - [ ] スキーマ型
  - [ ] 配列・オプショナル

**成果物:**
- `src/analyzer/types.ts`
- `src/analyzer/scope.ts`
- `src/analyzer/resolver.ts`
- `src/analyzer/type-checker.ts` (基本)

#### Week 4: Basic TypeScript Codegen

**タスク:**
- [ ] MIR定義（簡略版）
- [ ] IR生成（基本）
- [ ] TypeScript型生成
- [ ] 基本変換関数生成
- [ ] ランタイムライブラリ（基本）

**成果物:**
- `src/ir/mir.ts`
- `src/ir/ir-gen.ts`
- `src/codegen/typescript/`
- `runtime/typescript/` (基本)

### 15.3 Phase 2: Core Features

#### Week 5: Unit System

**タスク:**
- [ ] 次元・単位の型定義
- [ ] 単位式パーサー
- [ ] 次元解析
- [ ] 単位チェッカー
- [ ] Quantityランタイム

**成果物:**
- `src/analyzer/units.ts`
- `src/analyzer/unit-checker.ts`
- `runtime/typescript/quantity.ts`

#### Week 6: Type Checker Complete

**タスク:**
- [ ] 変換の型チェック
- [ ] 式の型推論
- [ ] ルックアップの型チェック
- [ ] ターゲット参照の解決
- [ ] 型エラーメッセージ改善

**成果物:**
- `src/analyzer/type-checker.ts` (完全版)
- `src/errors/messages.ts`

#### Week 7: IR & Optimization

**タスク:**
- [ ] MIR定義（完全版）
- [ ] IR生成（完全版）
- [ ] 最適化パス
  - [ ] 定数畳み込み
  - [ ] 共通部分式除去
  - [ ] デッドコード除去

**成果物:**
- `src/ir/mir.ts` (完全版)
- `src/ir/ir-gen.ts` (完全版)
- `src/ir/optimizer.ts`

#### Week 8: Full TypeScript Codegen

**タスク:**
- [ ] 全変換パターンのコード生成
- [ ] パイプライン生成
- [ ] JSON Schema生成
- [ ] ランタイムライブラリ完成

**成果物:**
- `src/codegen/typescript/` (完全版)
- `src/codegen/json-schema/`
- `runtime/typescript/` (完全版)

### 15.4 Phase 3: Extended Features

#### Week 9: Aggregations & Lookups

**タスク:**
- [ ] 集約関数の完全実装
- [ ] ルックアップの完全実装
- [ ] グループ化
- [ ] フィルタリング

**成果物:**
- 集約関数の型チェック・コード生成
- ルックアップのランタイム

#### Week 10: Python Codegen

**タスク:**
- [ ] Python型生成
- [ ] Python変換関数生成
- [ ] Pythonランタイム

**成果物:**
- `src/codegen/python/`
- `runtime/python/`

#### Week 11: CLI & Config

**タスク:**
- [ ] CLIコマンド実装
- [ ] 設定ファイルサポート
- [ ] Watch mode
- [ ] プロジェクト初期化

**成果物:**
- `src/cli/`
- 設定ファイルスキーマ

#### Week 12: Documentation & Examples

**タスク:**
- [ ] ドキュメント生成機能
- [ ] CFP計算例
- [ ] その他のサンプル
- [ ] README・ガイド

**成果物:**
- `src/codegen/docs/`
- `examples/`
- `docs/`

### 15.5 Phase 4: Polish

#### Week 13: Error Messages & UX

**タスク:**
- [ ] エラーメッセージ改善
- [ ] 提案機能
- [ ] ソースマップ
- [ ] LSP対応（基本）

**成果物:**
- 改善されたエラー報告
- LSPサーバー（基本）

#### Week 14: Testing & Release

**タスク:**
- [ ] テストカバレッジ向上
- [ ] パフォーマンステスト
- [ ] ドキュメント最終化
- [ ] npmパッケージ公開準備

**成果物:**
- 完全なテストスイート
- 公開可能なパッケージ

### 15.6 マイルストーン

| マイルストーン | 目標日 | 成果物 |
|--------------|-------|-------|
| M1: Parser完成 | Week 2 | 全構文をパース可能 |
| M2: 型チェック基本 | Week 4 | 基本的な型エラー検出 |
| M3: TS出力MVP | Week 4 | 簡単な変換がTSで実行可能 |
| M4: 単位システム | Week 6 | 単位付き計算の型チェック |
| M5: 完全なTS出力 | Week 8 | 全機能のTS出力 |
| M6: Python出力 | Week 10 | Python出力対応 |
| M7: CLI完成 | Week 11 | 全CLIコマンド |
| M8: リリース | Week 14 | v1.0.0リリース |

---

## 16. 完全なサンプル実装

### 16.1 CFP計算の完全例

#### 16.1.1 Morpheusソースコード

```morpheus
// cfp-calculation.morpheus
// CFP（カーボンフットプリント）計算の完全な例

// ========================================
// 次元と単位の定義
// ========================================

dimension Energy
dimension Mass
dimension Length
dimension CO2Emission

unit kWh: Energy
unit kg: Mass
unit km: Length
unit kgCO2: CO2Emission

// 派生単位（排出係数）
unit kgCO2_per_kWh = kgCO2 / kWh
unit kgCO2_per_kg = kgCO2 / kg
unit kgCO2_per_tkm = kgCO2 / (kg * km)

// ========================================
// 列挙型
// ========================================

enum TransportMode {
  Truck,
  Rail,
  Ship,
  Air
}

enum DisposalMethod {
  Landfill,
  Incineration,
  Recycle
}

enum FuelType {
  Diesel,
  Gasoline,
  NaturalGas,
  LPG
}

// ========================================
// ソーススキーマ（生産管理データ）
// ========================================

schema ProductionRecord {
  productId: String
  productionDate: Date
  lotNumber: String
  
  process: ProcessData
  materials: [MaterialUsage]
  logistics: LogisticsData
  waste: WasteData
}

schema ProcessData {
  machineId: String
  electricityUsage: Quantity<kWh>
  fuelUsage: Quantity<kg>
  fuelType: FuelType
  operatingHours: Float
}

schema MaterialUsage {
  materialCode: String
  materialName: String
  weight: Quantity<kg>
  supplierCode: String
  isRecycled: Bool
}

schema LogisticsData {
  inbound: TransportSegment
  outbound: TransportSegment
}

schema TransportSegment {
  distance: Quantity<km>
  transportMode: TransportMode
  cargoWeight: Quantity<kg>
}

schema WasteData {
  amount: Quantity<kg>
  disposalMethod: DisposalMethod
  wasteCode: String
}

// ========================================
// ターゲットスキーマ（CFP計算結果）
// ========================================

schema CFPResult {
  productId: String
  calculatedAt: DateTime
  
  // Scope別排出量
  scope1: ScopeEmission
  scope2: ScopeEmission
  scope3: Scope3Emission
  
  // 合計
  total: Quantity<kgCO2>
  
  // 内訳
  breakdown: EmissionBreakdown
}

schema ScopeEmission {
  emission: Quantity<kgCO2>
  category: String
}

schema Scope3Emission {
  upstream: Quantity<kgCO2>
  downstream: Quantity<kgCO2>
  total: Quantity<kgCO2>
}

schema EmissionBreakdown {
  electricity: Quantity<kgCO2>
  fuel: Quantity<kgCO2>
  materials: Quantity<kgCO2>
  inboundTransport: Quantity<kgCO2>
  outboundTransport: Quantity<kgCO2>
  waste: Quantity<kgCO2>
}

// ========================================
// ルックアップテーブル（排出係数）
// ========================================

@description("電力の排出係数（地域別）")
lookup ElectricityFactor {
  key: String  // region code
  value: Quantity<kgCO2_per_kWh>
  source: "data/emission_factors/electricity.csv"
  default: 0.441  // 日本のデフォルト値
}

@description("燃料の排出係数（燃料種別）")
lookup FuelFactor {
  key: FuelType
  value: Quantity<kgCO2_per_kg>
  source: "data/emission_factors/fuel.csv"
}

@description("原材料の排出係数（材料コード別）")
lookup MaterialFactor {
  key: String  // material code
  value: Quantity<kgCO2_per_kg>
  source: "data/emission_factors/materials.csv"
  default: 1.0
}

@description("輸送の排出係数（輸送モード別）")
lookup TransportFactor {
  key: TransportMode
  value: Quantity<kgCO2_per_tkm>
  source: "data/emission_factors/transport.csv"
}

@description("廃棄物処理の排出係数（処理方法別）")
lookup WasteFactor {
  key: DisposalMethod
  value: Quantity<kgCO2_per_kg>
  source: "data/emission_factors/waste.csv"
}

// ========================================
// 変換定義
// ========================================

@description("生産管理データからCFPを計算する")
@version("1.0.0")
@author("CFP Calculation Team")
transform ProductionToCFP: ProductionRecord -> CFPResult {
  
  // 基本情報
  productId <- $.productId
  calculatedAt <- now()
  
  // Scope1: 直接排出（燃料燃焼）
  scope1 <- {
    emission: $.process.fuelUsage * lookup(FuelFactor, $.process.fuelType),
    category: "Direct emissions from fuel combustion"
  }
  
  // Scope2: 間接排出（電力）
  scope2 <- {
    emission: $.process.electricityUsage * lookup(ElectricityFactor, "japan"),
    category: "Indirect emissions from purchased electricity"
  }
  
  // Scope3: サプライチェーン排出
  scope3 <- {
    // 上流（原材料 + 入荷輸送）
    upstream: 
      sum($.materials, |m| 
        if m.isRecycled 
        then m.weight * lookup(MaterialFactor, m.materialCode) * 0.1
        else m.weight * lookup(MaterialFactor, m.materialCode)
      )
      + calcTransportEmission($.logistics.inbound),
    
    // 下流（出荷輸送 + 廃棄処理）
    downstream:
      calcTransportEmission($.logistics.outbound)
      + $.waste.amount * lookup(WasteFactor, $.waste.disposalMethod),
    
    // Scope3合計
    total: @scope3.upstream + @scope3.downstream
  }
  
  // 合計
  total <- @scope1.emission + @scope2.emission + @scope3.total
  
  // 内訳
  breakdown <- {
    electricity: @scope2.emission,
    fuel: @scope1.emission,
    materials: sum($.materials, |m| m.weight * lookup(MaterialFactor, m.materialCode)),
    inboundTransport: calcTransportEmission($.logistics.inbound),
    outboundTransport: calcTransportEmission($.logistics.outbound),
    waste: $.waste.amount * lookup(WasteFactor, $.waste.disposalMethod)
  }
}

// ヘルパー変換（輸送排出量計算）
transform calcTransportEmission: TransportSegment -> Quantity<kgCO2> {
  @ <- $.distance * $.cargoWeight * lookup(TransportFactor, $.transportMode)
}

// ========================================
// パイプライン
// ========================================

@description("完全なCFP計算パイプライン")
pipeline FullCFPPipeline {
  // 入力データの正規化
  NormalizeInput
  
  // メイン変換
  ProductionToCFP
  
  // 結果の検証
  ValidateCFPResult
  
  // 四捨五入
  RoundResult
}

// 正規化変換
transform NormalizeInput: ProductionRecord -> ProductionRecord {
  productId <- $.productId
  productionDate <- $.productionDate
  lotNumber <- $.lotNumber
  process <- $.process
  materials <- filter($.materials, |m| m.weight.value > 0)
  logistics <- $.logistics
  waste <- $.waste
}

// 検証変換
transform ValidateCFPResult: CFPResult -> CFPResult {
  productId <- $.productId
  calculatedAt <- $.calculatedAt
  scope1 <- $.scope1
  scope2 <- $.scope2
  scope3 <- $.scope3
  total <- if $.total.value >= 0 then $.total else { value: 0, unit: "kgCO2" }
  breakdown <- $.breakdown
}

// 四捨五入変換
transform RoundResult: CFPResult -> CFPResult {
  productId <- $.productId
  calculatedAt <- $.calculatedAt
  scope1 <- { 
    emission: round($.scope1.emission, 2),
    category: $.scope1.category
  }
  scope2 <- {
    emission: round($.scope2.emission, 2),
    category: $.scope2.category
  }
  scope3 <- {
    upstream: round($.scope3.upstream, 2),
    downstream: round($.scope3.downstream, 2),
    total: round($.scope3.total, 2)
  }
  total <- round($.total, 2)
  breakdown <- {
    electricity: round($.breakdown.electricity, 2),
    fuel: round($.breakdown.fuel, 2),
    materials: round($.breakdown.materials, 2),
    inboundTransport: round($.breakdown.inboundTransport, 2),
    outboundTransport: round($.breakdown.outboundTransport, 2),
    waste: round($.breakdown.waste, 2)
  }
}
```

#### 16.1.2 生成されるTypeScriptコード

```typescript
// dist/types.ts (生成)

import { Quantity } from '@morpheus/runtime';

export enum TransportMode {
  Truck = 'Truck',
  Rail = 'Rail',
  Ship = 'Ship',
  Air = 'Air',
}

export enum DisposalMethod {
  Landfill = 'Landfill',
  Incineration = 'Incineration',
  Recycle = 'Recycle',
}

export enum FuelType {
  Diesel = 'Diesel',
  Gasoline = 'Gasoline',
  NaturalGas = 'NaturalGas',
  LPG = 'LPG',
}

export interface ProductionRecord {
  productId: string;
  productionDate: Date;
  lotNumber: string;
  process: ProcessData;
  materials: MaterialUsage[];
  logistics: LogisticsData;
  waste: WasteData;
}

export interface ProcessData {
  machineId: string;
  electricityUsage: Quantity<'kWh'>;
  fuelUsage: Quantity<'kg'>;
  fuelType: FuelType;
  operatingHours: number;
}

export interface MaterialUsage {
  materialCode: string;
  materialName: string;
  weight: Quantity<'kg'>;
  supplierCode: string;
  isRecycled: boolean;
}

export interface LogisticsData {
  inbound: TransportSegment;
  outbound: TransportSegment;
}

export interface TransportSegment {
  distance: Quantity<'km'>;
  transportMode: TransportMode;
  cargoWeight: Quantity<'kg'>;
}

export interface WasteData {
  amount: Quantity<'kg'>;
  disposalMethod: DisposalMethod;
  wasteCode: string;
}

export interface CFPResult {
  productId: string;
  calculatedAt: Date;
  scope1: ScopeEmission;
  scope2: ScopeEmission;
  scope3: Scope3Emission;
  total: Quantity<'kgCO2'>;
  breakdown: EmissionBreakdown;
}

export interface ScopeEmission {
  emission: Quantity<'kgCO2'>;
  category: string;
}

export interface Scope3Emission {
  upstream: Quantity<'kgCO2'>;
  downstream: Quantity<'kgCO2'>;
  total: Quantity<'kgCO2'>;
}

export interface EmissionBreakdown {
  electricity: Quantity<'kgCO2'>;
  fuel: Quantity<'kgCO2'>;
  materials: Quantity<'kgCO2'>;
  inboundTransport: Quantity<'kgCO2'>;
  outboundTransport: Quantity<'kgCO2'>;
  waste: Quantity<'kgCO2'>;
}
```

```typescript
// dist/transforms/ProductionToCFP.ts (生成)

import { 
  Quantity, multiply, add, sum, createQuantity 
} from '@morpheus/runtime';
import * as Types from '../types';
import * as Lookups from '../lookups';

export function ProductionToCFP(source: Types.ProductionRecord): Types.CFPResult {
  // Scope1: 燃料燃焼
  const _t1 = Lookups.FuelFactor.get(source.process.fuelType);
  const scope1Emission = multiply(source.process.fuelUsage, _t1);
  
  // Scope2: 電力
  const _t2 = Lookups.ElectricityFactor.get('japan');
  const scope2Emission = multiply(source.process.electricityUsage, _t2);
  
  // Scope3上流: 原材料
  const materialsEmission = sum(source.materials, (m) => {
    const factor = Lookups.MaterialFactor.get(m.materialCode);
    const baseEmission = multiply(m.weight, factor);
    return m.isRecycled 
      ? createQuantity(baseEmission.value * 0.1, baseEmission.unit)
      : baseEmission;
  });
  
  // Scope3上流: 入荷輸送
  const inboundEmission = calcTransportEmission(source.logistics.inbound);
  
  const scope3Upstream = add(materialsEmission, inboundEmission);
  
  // Scope3下流: 出荷輸送
  const outboundEmission = calcTransportEmission(source.logistics.outbound);
  
  // Scope3下流: 廃棄
  const _t3 = Lookups.WasteFactor.get(source.waste.disposalMethod);
  const wasteEmission = multiply(source.waste.amount, _t3);
  
  const scope3Downstream = add(outboundEmission, wasteEmission);
  
  const scope3Total = add(scope3Upstream, scope3Downstream);
  
  // 合計
  const total = add(add(scope1Emission, scope2Emission), scope3Total);
  
  return {
    productId: source.productId,
    calculatedAt: new Date(),
    scope1: {
      emission: scope1Emission,
      category: 'Direct emissions from fuel combustion'
    },
    scope2: {
      emission: scope2Emission,
      category: 'Indirect emissions from purchased electricity'
    },
    scope3: {
      upstream: scope3Upstream,
      downstream: scope3Downstream,
      total: scope3Total
    },
    total,
    breakdown: {
      electricity: scope2Emission,
      fuel: scope1Emission,
      materials: materialsEmission,
      inboundTransport: inboundEmission,
      outboundTransport: outboundEmission,
      waste: wasteEmission
    }
  };
}

function calcTransportEmission(segment: Types.TransportSegment): Quantity<'kgCO2'> {
  const factor = Lookups.TransportFactor.get(segment.transportMode);
  const tonKm = multiply(segment.distance, segment.cargoWeight);
  return multiply(tonKm, factor);
}
```

#### 16.1.3 使用例

```typescript
// example-usage.ts

import { ProductionToCFP } from './dist';
import { FuelType, TransportMode, DisposalMethod } from './dist/types';

const productionData = {
  productId: 'PROD-2024-001',
  productionDate: new Date('2024-01-15'),
  lotNumber: 'LOT-001',
  
  process: {
    machineId: 'MC-001',
    electricityUsage: { value: 150, unit: 'kWh' as const },
    fuelUsage: { value: 10, unit: 'kg' as const },
    fuelType: FuelType.Diesel,
    operatingHours: 8
  },
  
  materials: [
    {
      materialCode: 'STEEL-001',
      materialName: '鋼材',
      weight: { value: 50, unit: 'kg' as const },
      supplierCode: 'SUP-001',
      isRecycled: false
    },
    {
      materialCode: 'PLASTIC-001',
      materialName: 'プラスチック',
      weight: { value: 5, unit: 'kg' as const },
      supplierCode: 'SUP-002',
      isRecycled: true
    }
  ],
  
  logistics: {
    inbound: {
      distance: { value: 200, unit: 'km' as const },
      transportMode: TransportMode.Truck,
      cargoWeight: { value: 55, unit: 'kg' as const }
    },
    outbound: {
      distance: { value: 100, unit: 'km' as const },
      transportMode: TransportMode.Truck,
      cargoWeight: { value: 45, unit: 'kg' as const }
    }
  },
  
  waste: {
    amount: { value: 10, unit: 'kg' as const },
    disposalMethod: DisposalMethod.Incineration,
    wasteCode: 'WASTE-001'
  }
};

const result = ProductionToCFP(productionData);

console.log('=== CFP計算結果 ===');
console.log(`製品ID: ${result.productId}`);
console.log(`計算日時: ${result.calculatedAt}`);
console.log();
console.log('--- Scope別排出量 ---');
console.log(`Scope1 (直接排出): ${result.scope1.emission.value.toFixed(2)} ${result.scope1.emission.unit}`);
console.log(`Scope2 (電力): ${result.scope2.emission.value.toFixed(2)} ${result.scope2.emission.unit}`);
console.log(`Scope3 上流: ${result.scope3.upstream.value.toFixed(2)} kgCO2`);
console.log(`Scope3 下流: ${result.scope3.downstream.value.toFixed(2)} kgCO2`);
console.log();
console.log(`合計: ${result.total.value.toFixed(2)} ${result.total.unit}`);
console.log();
console.log('--- 内訳 ---');
console.log(`  電力: ${result.breakdown.electricity.value.toFixed(2)} kgCO2`);
console.log(`  燃料: ${result.breakdown.fuel.value.toFixed(2)} kgCO2`);
console.log(`  原材料: ${result.breakdown.materials.value.toFixed(2)} kgCO2`);
console.log(`  入荷輸送: ${result.breakdown.inboundTransport.value.toFixed(2)} kgCO2`);
console.log(`  出荷輸送: ${result.breakdown.outboundTransport.value.toFixed(2)} kgCO2`);
console.log(`  廃棄: ${result.breakdown.waste.value.toFixed(2)} kgCO2`);
```

---

## 付録

### 付録A: ファイル形式

#### A.1 .morpheus ファイル

- エンコーディング: UTF-8
- 拡張子: `.morpheus`
- MIME type: `text/x-morpheus`

#### A.2 設定ファイル

- 形式: JSON
- ファイル名: `morpheus.config.json`

### 付録B: エラーコード一覧

| コード | カテゴリ | メッセージ |
|--------|---------|-----------|
| L001 | Lexer | Unexpected character |
| L002 | Lexer | Unterminated string |
| P001 | Parser | Expected declaration |
| P002 | Parser | Expected identifier |
| T001 | Type | Unknown type |
| T002 | Type | Type mismatch |
| T003 | Type | Unknown field |
| T004 | Type | Missing required field |
| U001 | Unit | Unknown unit |
| U002 | Unit | Unit mismatch in addition |

### 付録C: 組み込み関数

| 関数 | 説明 | シグネチャ |
|------|------|-----------|
| `now()` | 現在日時 | `() -> DateTime` |
| `today()` | 今日の日付 | `() -> Date` |
| `round(q, n)` | 四捨五入 | `(Quantity<U>, Int) -> Quantity<U>` |
| `abs(q)` | 絶対値 | `(Quantity<U>) -> Quantity<U>` |
| `sqrt(n)` | 平方根 | `(Float) -> Float` |

---

**End of Morpheus DSL Specification Part 2**

このドキュメントと Part 1 を組み合わせることで、Morpheus DSL の完全な実装が可能です。
