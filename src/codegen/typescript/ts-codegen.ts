// TypeScript Code Generator for Morpheus DSL

import * as MIR from '../../ir/mir';

export class TypeScriptCodegen {
  private output: string[] = [];
  private indent = 0;

  generate(program: MIR.MIRProgram): Map<string, string> {
    const files = new Map<string, string>();

    // types.ts - Schema and Enum definitions
    files.set('types.ts', this.generateTypes(program));

    // transforms.ts - Transform functions
    files.set('transforms.ts', this.generateTransforms(program));

    // index.ts - Main export
    files.set('index.ts', this.generateIndex(program));

    return files;
  }

  // ========== Type Generation ==========

  private generateTypes(program: MIR.MIRProgram): string {
    this.output = [];

    this.emit('// Auto-generated by Morpheus DSL Compiler');
    this.emit('// Do not edit manually');
    this.emit('');
    this.emit('export interface Quantity<Unit extends string> {');
    this.emit('  value: number;');
    this.emit('  unit: Unit;');
    this.emit('}');
    this.emit('');

    // Enums
    for (const [_name, enumDef] of program.enums) {
      this.generateEnum(enumDef);
      this.emit('');
    }

    // Schemas
    for (const [_name, schema] of program.schemas) {
      this.generateSchema(schema);
      this.emit('');
    }

    return this.output.join('\n');
  }

  private generateEnum(enumDef: MIR.MIREnum): void {
    this.emit(`export enum ${enumDef.name} {`);
    this.indent++;
    for (const variant of enumDef.variants) {
      this.emit(`${variant} = '${variant}',`);
    }
    this.indent--;
    this.emit('}');
  }

  private generateSchema(schema: MIR.MIRSchema): void {
    this.emit(`export interface ${schema.name} {`);
    this.indent++;

    for (const field of schema.fields) {
      const tsType = this.mirTypeToTS(field.type);
      this.emit(`${field.name}: ${tsType};`);
    }

    this.indent--;
    this.emit('}');
  }

  private mirTypeToTS(type: MIR.MIRType): string {
    switch (type.kind) {
      case 'Primitive':
        return this.primitiveToTS(type.name);
      case 'Schema':
        return `Types.${type.name}`;
      case 'Enum':
        return `Types.${type.name}`;
      case 'Array':
        return `${this.mirTypeToTS(type.element)}[]`;
      case 'Optional':
        return `${this.mirTypeToTS(type.inner)} | null`;
      case 'Quantity':
        return `Types.Quantity<'${type.unit}'>`;
      case 'Tuple':
        return `[${type.elements.map(e => this.mirTypeToTS(e)).join(', ')}]`;
      case 'Union':
        return type.members.map(m => this.mirTypeToTS(m)).join(' | ');
      default:
        return 'unknown';
    }
  }

  private primitiveToTS(name: string): string {
    switch (name) {
      case 'String':
        return 'string';
      case 'Int':
      case 'Float':
        return 'number';
      case 'Bool':
        return 'boolean';
      case 'Date':
      case 'DateTime':
        return 'Date';
      case 'Void':
        return 'void';
      default:
        return 'unknown';
    }
  }

  // ========== Transform Generation ==========

  private generateTransforms(program: MIR.MIRProgram): string {
    this.output = [];

    this.emit('// Auto-generated transform functions');
    this.emit('');
    this.emit('import * as Types from \'./types\';');
    this.emit('');

    for (const [_name, transform] of program.transforms) {
      this.generateTransform(transform);
      this.emit('');
    }

    return this.output.join('\n');
  }

  private generateTransform(transform: MIR.MIRTransform): void {
    const sourceType = this.mirTypeToTS(transform.sourceType);
    const targetType = this.mirTypeToTS(transform.targetType);

    this.emit(`export function ${transform.name}(source: ${sourceType}): ${targetType} {`);
    this.indent++;

    // Initialize result object
    this.emit('const result: any = {};');
    this.emit('');

    // Generate field assignments from MIR instructions
    for (const instr of transform.body.instructions) {
      this.generateInstruction(instr);
    }

    this.emit('');
    this.emit('return result;');
    this.indent--;
    this.emit('}');
  }

  private generateInstruction(instr: MIR.MIRInstruction): void {
    switch (instr.kind) {
      case 'FieldSet':
        const value = this.generateValue(instr.value);
        this.emit(`result.${instr.field} = ${value};`);
        break;

      case 'Assign':
        const assignValue = this.generateValue(instr.value);
        this.emit(`const ${instr.target} = ${assignValue};`);
        break;

      case 'FieldGet':
        const obj = this.generateValue(instr.object);
        this.emit(`const ${instr.target} = ${obj}.${instr.field};`);
        break;

      case 'BinOp':
        const left = this.generateValue(instr.left);
        const right = this.generateValue(instr.right);
        this.emit(`const ${instr.target} = ${left} ${instr.op} ${right};`);
        break;

      default:
        this.emit(`// Unsupported instruction: ${instr.kind}`);
        break;
    }
  }

  private generateValue(value: MIR.MIRValue): string {
    switch (value.kind) {
      case 'Var':
        return value.name;
      case 'IntLit':
      case 'FloatLit':
        return String(value.value);
      case 'StringLit':
        return JSON.stringify(value.value);
      case 'BoolLit':
        return String(value.value);
      case 'Null':
        return 'null';
      case 'SourceRef':
        return 'source';
      case 'TargetRef':
        return `result.${value.field}`;
      default:
        return 'undefined';
    }
  }

  // ========== Index Generation ==========

  private generateIndex(_program: MIR.MIRProgram): string {
    this.output = [];

    this.emit('// Auto-generated index');
    this.emit('');
    this.emit('export * from \'./types\';');
    this.emit('export * from \'./transforms\';');

    return this.output.join('\n');
  }

  // ========== Helper Methods ==========

  private emit(line: string): void {
    if (line === '') {
      this.output.push('');
    } else {
      const indentation = '  '.repeat(this.indent);
      this.output.push(indentation + line);
    }
  }
}
