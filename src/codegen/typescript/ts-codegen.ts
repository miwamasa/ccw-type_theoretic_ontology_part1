// TypeScript Code Generator for Morpheus DSL

import * as MIR from '../../ir/mir';

export class TypeScriptCodegen {
  private output: string[] = [];
  private indent = 0;

  generate(program: MIR.MIRProgram): Map<string, string> {
    const files = new Map<string, string>();

    // types.ts - Schema and Enum definitions
    files.set('types.ts', this.generateTypes(program));

    // transforms.ts - Transform functions
    files.set('transforms.ts', this.generateTransforms(program));

    // index.ts - Main export
    files.set('index.ts', this.generateIndex(program));

    // tsconfig.json - TypeScript configuration
    files.set('tsconfig.json', this.generateTsConfig());

    // package.json - Package configuration
    files.set('package.json', this.generatePackageJson());

    // test.ts - Test file
    files.set('test.ts', this.generateTest(program));

    return files;
  }

  // ========== Type Generation ==========

  private generateTypes(program: MIR.MIRProgram): string {
    this.output = [];

    this.emit('// Auto-generated by Morpheus DSL Compiler');
    this.emit('// Do not edit manually');
    this.emit('');
    this.emit('export interface Quantity<Unit extends string> {');
    this.emit('  value: number;');
    this.emit('  unit: Unit;');
    this.emit('}');
    this.emit('');

    // Enums
    for (const [_name, enumDef] of program.enums) {
      this.generateEnum(enumDef);
      this.emit('');
    }

    // Schemas
    for (const [_name, schema] of program.schemas) {
      this.generateSchema(schema);
      this.emit('');
    }

    return this.output.join('\n');
  }

  private generateEnum(enumDef: MIR.MIREnum): void {
    this.emit(`export enum ${enumDef.name} {`);
    this.indent++;
    for (const variant of enumDef.variants) {
      this.emit(`${variant} = '${variant}',`);
    }
    this.indent--;
    this.emit('}');
  }

  private generateSchema(schema: MIR.MIRSchema): void {
    this.emit(`export interface ${schema.name} {`);
    this.indent++;

    for (const field of schema.fields) {
      const tsType = this.mirTypeToTSLocal(field.type);
      this.emit(`${field.name}: ${tsType};`);
    }

    this.indent--;
    this.emit('}');
  }

  private mirTypeToTS(type: MIR.MIRType): string {
    switch (type.kind) {
      case 'Primitive':
        return this.primitiveToTS(type.name);
      case 'Schema':
        return `Types.${type.name}`;
      case 'Enum':
        return `Types.${type.name}`;
      case 'Array':
        return `${this.mirTypeToTS(type.element)}[]`;
      case 'Optional':
        return `${this.mirTypeToTS(type.inner)} | null`;
      case 'Quantity':
        return `Types.Quantity<'${type.unit}'>`;
      case 'Tuple':
        return `[${type.elements.map(e => this.mirTypeToTS(e)).join(', ')}]`;
      case 'Union':
        return type.members.map(m => this.mirTypeToTS(m)).join(' | ');
      default:
        return 'unknown';
    }
  }

  private mirTypeToTSLocal(type: MIR.MIRType): string {
    switch (type.kind) {
      case 'Primitive':
        return this.primitiveToTS(type.name);
      case 'Schema':
        return type.name;
      case 'Enum':
        return type.name;
      case 'Array':
        return `${this.mirTypeToTSLocal(type.element)}[]`;
      case 'Optional':
        return `${this.mirTypeToTSLocal(type.inner)} | null`;
      case 'Quantity':
        return `Quantity<'${type.unit}'>`;
      case 'Tuple':
        return `[${type.elements.map(e => this.mirTypeToTSLocal(e)).join(', ')}]`;
      case 'Union':
        return type.members.map(m => this.mirTypeToTSLocal(m)).join(' | ');
      default:
        return 'unknown';
    }
  }

  private primitiveToTS(name: string): string {
    switch (name) {
      case 'String':
        return 'string';
      case 'Int':
      case 'Float':
        return 'number';
      case 'Bool':
        return 'boolean';
      case 'Date':
      case 'DateTime':
        return 'Date';
      case 'Void':
        return 'void';
      default:
        return 'unknown';
    }
  }

  // ========== Transform Generation ==========

  private generateTransforms(program: MIR.MIRProgram): string {
    this.output = [];

    this.emit('// Auto-generated transform functions');
    this.emit('');
    this.emit('import * as Types from \'./types\';');
    this.emit('');

    // Declare lookup tables (to be populated at runtime)
    if (program.lookups.size > 0) {
      this.emit('// Lookup tables (populate these before using transforms)');
      for (const [name, _lookup] of program.lookups) {
        this.emit(`declare const ${name}: any;`);
      }
      this.emit('');
    }

    for (const [_name, transform] of program.transforms) {
      this.generateTransform(transform);
      this.emit('');
    }

    return this.output.join('\n');
  }

  private generateTransform(transform: MIR.MIRTransform): void {
    const sourceType = this.mirTypeToTS(transform.sourceType);
    const targetType = this.mirTypeToTS(transform.targetType);

    this.emit(`export function ${transform.name}(source: ${sourceType}): ${targetType} {`);
    this.indent++;

    // Initialize result object
    this.emit('const result: any = {};');
    this.emit('');

    // Generate field assignments from MIR instructions
    for (const instr of transform.body.instructions) {
      this.generateInstruction(instr);
    }

    this.emit('');
    this.emit('return result;');
    this.indent--;
    this.emit('}');
  }

  private generateInstruction(instr: MIR.MIRInstruction): void {
    switch (instr.kind) {
      case 'FieldSet':
        const value = this.generateValue(instr.value);
        this.emit(`result.${instr.field} = ${value};`);
        break;

      case 'Assign':
        const assignValue = this.generateValue(instr.value);
        this.emit(`const ${instr.target} = ${assignValue};`);
        break;

      case 'FieldGet':
        const obj = this.generateValue(instr.object);
        this.emit(`const ${instr.target} = ${obj}.${instr.field};`);
        break;

      case 'BinOp':
        const left = this.generateValue(instr.left);
        const right = this.generateValue(instr.right);
        // Note: Quantity arithmetic is not fully implemented yet
        // This will fail at runtime if operands are Quantity objects
        this.emit(`const ${instr.target} = ${left} ${instr.op} ${right};`);
        break;

      case 'Lookup':
        const keyValue = this.generateValue(instr.key);
        if (instr.default) {
          const defaultValue = this.generateValue(instr.default);
          this.emit(`const ${instr.target} = ${instr.table}[${keyValue}] ?? ${defaultValue};`);
        } else {
          this.emit(`const ${instr.target} = ${instr.table}[${keyValue}];`);
        }
        break;

      default:
        this.emit(`// Unsupported instruction: ${instr.kind}`);
        break;
    }
  }

  private generateValue(value: MIR.MIRValue): string {
    switch (value.kind) {
      case 'Var':
        return value.name;
      case 'IntLit':
      case 'FloatLit':
        return String(value.value);
      case 'StringLit':
        return JSON.stringify(value.value);
      case 'BoolLit':
        return String(value.value);
      case 'Null':
        return 'null';
      case 'SourceRef':
        return 'source';
      case 'TargetRef':
        return `result.${value.field}`;
      default:
        return 'undefined';
    }
  }

  // ========== Index Generation ==========

  private generateIndex(_program: MIR.MIRProgram): string {
    this.output = [];

    this.emit('// Auto-generated index');
    this.emit('');
    this.emit('export * from \'./types\';');
    this.emit('export * from \'./transforms\';');

    return this.output.join('\n');
  }

  // ========== Test Generation ==========

  private generateTest(program: MIR.MIRProgram): string {
    this.output = [];

    this.emit('// Auto-generated test file');
    this.emit('');
    this.emit('import * as Types from \'./types\';');
    this.emit('import * as Transforms from \'./transforms\';');
    this.emit('');

    // Generate mock lookup tables
    if (program.lookups.size > 0) {
      this.emit('// Mock lookup tables');
      for (const [name, _lookup] of program.lookups) {
        this.emit(`const ${name}: any = {`);
        this.emit(`  'electricity': { value: 0.5, unit: 'kgCO2_per_kWh' },`);
        this.emit(`  'default': { value: 0.0, unit: 'kgCO2_per_kWh' }`);
        this.emit(`};`);
      }
      this.emit('');
    }

    // Generate test data for each transform
    for (const [name, transform] of program.transforms) {
      this.generateTransformTest(name, transform, program);
      this.emit('');
    }

    return this.output.join('\n');
  }

  private generateTransformTest(name: string, transform: MIR.MIRTransform, program: MIR.MIRProgram): void {
    // Generate sample source data
    this.emit(`// Test for ${name}`);
    const sourceData = this.generateSampleData(transform.sourceType, program);
    this.emit(`const testData_${name} = ${sourceData};`);
    this.emit('');

    // Call the transform
    this.emit(`const result_${name} = Transforms.${name}(testData_${name});`);
    this.emit('');

    // Output results
    this.emit(`console.log('=== ${name} ===');`);
    this.emit(`console.log('Input:', testData_${name});`);
    this.emit(`console.log('Output:', result_${name});`);
    this.emit(`console.log('âœ“ ${name} executed successfully!');`);
    this.emit(`console.log('');`);
  }

  private generateSampleData(type: MIR.MIRType, program: MIR.MIRProgram): string {
    switch (type.kind) {
      case 'Primitive':
        return this.generatePrimitiveSample(type.name);

      case 'Schema':
        const schema = program.schemas.get(type.name);
        if (!schema) return '{}';

        const fields: string[] = [];
        for (const field of schema.fields) {
          const value = this.generateSampleData(field.type, program);
          fields.push(`${field.name}: ${value}`);
        }
        return `{ ${fields.join(', ')} }`;

      case 'Array':
        const elementSample = this.generateSampleData(type.element, program);
        return `[${elementSample}]`;

      case 'Optional':
        return this.generateSampleData(type.inner, program);

      case 'Enum':
        const enumDef = program.enums.get(type.name);
        if (enumDef && enumDef.variants.length > 0) {
          return `Types.${type.name}.${enumDef.variants[0]}`;
        }
        return `''`;

      case 'Quantity':
        return `{ value: 100, unit: '${type.unit}' as '${type.unit}' }`;

      default:
        return 'null';
    }
  }

  private generatePrimitiveSample(name: string): string {
    switch (name) {
      case 'String':
        return `'Sample String'`;
      case 'Int':
      case 'Float':
        return '42';
      case 'Bool':
        return 'true';
      case 'Date':
      case 'DateTime':
        return 'new Date()';
      default:
        return 'null';
    }
  }

  // ========== Configuration Files ==========

  private generateTsConfig(): string {
    const config = {
      compilerOptions: {
        target: 'ES2020',
        module: 'commonjs',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        outDir: './dist',
        declaration: true,
        sourceMap: true
      },
      include: ['*.ts'],
      exclude: ['dist', 'node_modules']
    };

    return JSON.stringify(config, null, 2);
  }

  private generatePackageJson(): string {
    const pkg = {
      name: 'morpheus-generated',
      version: '1.0.0',
      description: 'Generated by Morpheus DSL Compiler',
      main: 'dist/index.js',
      types: 'dist/index.d.ts',
      scripts: {
        build: 'tsc',
        clean: 'rm -rf dist'
      },
      devDependencies: {
        typescript: '^5.0.0'
      }
    };

    return JSON.stringify(pkg, null, 2);
  }

  // ========== Helper Methods ==========

  private emit(line: string): void {
    if (line === '') {
      this.output.push('');
    } else {
      const indentation = '  '.repeat(this.indent);
      this.output.push(indentation + line);
    }
  }
}
